= Datebase
Korov9 <korov9@163.com>
v1.0 2021-12-05
:toc: right
:imagesdir: images
:source-highlighter: pygments
:source-language: java

== 1.数据库范式

数据不会冗余，对于数据的增删改查是很友好的，但是需要更多的数据表关联操作降低性能。

=== 1.1 第一范式

所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。

=== 1.2 第二范式

在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）

第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分。

=== 1.3 第三范式

在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。

=== 1.4 BC范式

在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）

== 反范式

反范式会造成数据的冗余，同一个信息会出存储在多个地方。对于数据的增删改查是非常不利的。但是不需要表之间的关联操作，查询时间更短。

所有数据都在同一张表中可以使用索引策略来实现数据查询的优化，可以做的比范式更好
