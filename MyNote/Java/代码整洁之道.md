# 目标

对于需要处理的数据要立即处理，不要等到之后再处理：稍后等于永不。

**学会写整洁的代码**

不要重复代码，只做一件事（方法尽量只做一件或两件事情），表达力（通过代码表达出你想做的事情），小规模抽象（把相似的方法封装到更抽象的方法或类中）。代码最好有测试类测试代码是否可以正常运行。

# 有意义的命名

## 名字的中每个字母都要有用处，没用的字母和字符全部删掉。

聪明的程序员可以很快的用代码实现业务，专业的程序员可以很快的用可读性，可修改性极高的代码实现业务，优秀的程序员可以用如词句篇章的代码实现业务。

## 1.定义的名称要名副其实

一旦发现有更好的名称就换掉旧的。

变量、函数、或类的名称应该能够表述它为什么存在，它做了什么事、应该怎么用。

## 2.避免误导

不要使用与本意相悖的词，也不要使用有歧义或者其他平台（UNIX，LINUX）的专有名称。自己写的代码起名字要前后规则一致。

## 3.起名字的时候不同的名字要能足够表达不同的意思，不要在后面加1,2,3这样的数字

moneyAmount 就 与 money 没 区别， customerInfo 与 customer 没 区别， accountData 与 account 没 区别， theMessage 也 与 message 没 区别。

## 4.使用读得出来的名称

## 5.使用可搜索的名称

长名称更方便搜索，因此长名称胜于短名称。名称长短也应该与其作用域大小相对应，作用域更大的变量名称应该更长。

## 6.避免使用编码

不需要在名称中加上String，int等，这是以前匈牙利语标记法，原因，当时的编译器不能做类型检查，需要加上String等帮助程序员识别变量类型。

也不需要加上前缀后缀什么的。

接口可以使用编码，接口建议使用不加前导字母I的形式，例如ShapeFactory，实现类使用ShapeFactoryImp。

## 7.避免思维映射

不应当让读者把你的名称翻译为他们熟知的名称。

 

聪明的程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。

 

## 8.类名和对象名应该是名词或名词短语

## 9.方法名应当是动词或动词短语

## 10.每个概念对应一个词

给每个抽象概念选一个词，并且一以贯之。例如fetch，retrieve和get意思都是获取，那就全部统一使用get。例如controller，manager和driver意思相似，那么全文中都是用manager统一上下文。

## 11.别用双关语

避免将同一个单词用于不同的目的。add表示相加，insert表示向某个集群中插入数据

## 12.使用解决方案领域名称

可以尽情使用计算机科学术语、算法名、模式名、数学术语，因为读你代码的只有程序员。不要使用其他专业领域的名称命名。

## 13.使用源自所涉问题领域的名称

如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称，至少代码维护人员可以取请教领域专家

## 14.添加有意义的语境

使用良好的类名，函数名或空间名给读者提供语境。如果没有这样做那就通过添加前缀实现。例如在类Address中有state属性，人们就可以知道state代表地址状态。如果没有给类赋一个好名字那么使用addrState提供语境。

修改建议：若一个方法中有三个变量number，verb，pluralModifier零散的出现在方法中，将者三个变量封装到一个类中实现提供语境。

# 函数

大师级程序员把系统当做故事来讲，而不是当做程序来写。

## 如何写函数：

在刚开始的时候可以想什么就些什么，然后再打磨它。

写函数时，一开始都是冗长而复杂的。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复的代码。不过可以配上一套单元测试，覆盖每行丑陋的代码。

然后代码这些代码，分解函数、修改名称、消除重复。缩短和重新安置方法。有时候还可以拆散类。同时保持测试通过。

最后遵循以下列出的规则，组装好这些函数。

## 1.短小

函数每行不要超过150个字符，行数20行封顶最佳。

if、else、while语句等，其中的代码块应该只有一行，该行大抵是一个函数调用的语句。因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。

## 2.只做一件事

函数应该做一件事，做好这件事，只做这一件事

如果一个函数中还可以再拆解出一个函数，那么这个函数就需要拆解。

如果一个函数可以被合理的切分为多个区段，这个函数是可以拆解的

## 3.每个函数一个抽象层级

要确保函数只做一件事，函数中的语句都要在同一抽象层级上。

### 向下规则：

让每个函数后面都跟着位于下一抽象层级的函数，这样一来在查看函数列表时，就能循环抽象层级向下阅读了。

例制作铅笔：获取原料，制作（切多长，切成圆柱还是六面体等这些属于下一层级），包装（使用纸盒包装还是塑料包装属于下一层级），销售

## 4.switch语句（理解较难，因此描述较多）

如下代码

```java
public MoneycalculatePay(Employeee)throws InvalidEmployeeType{
    switch(e.type){
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

根据雇员类型执行不同的函数。问题：首先，太长，当出现新的雇员类型是，还会变得更长。其次，做了不只一件事。第三，违反了单一权责原则。第四，违反了开放闭合原则，因为每当添加新类型时，就必须修改之。

解决方案：将switch语句埋到抽象工厂中，该工厂使用switch语句为Employee的派生物穿件适当的实体，而不同的函数，如 calculatePay、 isPayday 和 deliverPay 等， 则 藉由 Employee 接口 多 态 地 接受 派遣。

Employee中的抽象方法

![clip_image001](picture\clip_image001.png)

创建不同Employee实体的工厂接口

![clip_image002](picture\clip_image002.png)

工厂实现根据类型返回不同实体，不同的实体实现Employee中的不同抽象方法

![clip_image003](picture\clip_image003.png)

## 5.使用描述性的名称

若长名称更具有描述性，那么就使用长名称。命名方式要保持一致，例如includeSetupAndTeardowmPages,includeSetupPages等。

## 6.函数参数

最理想的参数数量是零，其次是一，再次是二，应尽量避免三，有足够理由才能用三个以上参数。此外不要通过返回值从函数中输出。

不要使用标识参数，例如向函数传入布尔值，表明函数不只做了一件事，千万不要这样做。

不使用三元函数原因：三元函数有多种组合和排序，很容易出错，因此参数尽量少或者无参数。

若函数需要两个、三个或三个以上参数可以通过将函数封装在一个类中实现减少参数。

## 7.副作用

有时函数名表示只做了一件事，但是事实却做了不只一件事，多做的事可能带来不可预见的副作用，这时要将函数做的事情都表示清楚。

## 8.使用异常替代返回错误码

### 8.1抽离Try/Catch代码块

Try/Catch代码块丑陋不堪。他们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把Try/Catch代码块的主体部分抽离出来，另外形成函数。

![clip_image004](picture\clip_image004.png)

### 8.2错误处理就是一件事，也只应该只做一件事

## 9.别重复自己

重复可能是软件中一切邪恶的根源。

## 10.结构化编程

每个函数、函数中的每个代码块都应该有一个入口、一个出口。意味着每个函数中只该有一个return，循环中不能有break或continue语句。此规则在大函数中有益，小函数中可以不遵守此规则。

# 注释

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

如果你发现自己需要写注释，再想想看是否有办法翻盘，用代码来表达。

避免使用注释的原因，注释会撒谎，注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。原因很简单，程序员不能坚持维护注释。

## 1.好注释

有些注释是必须的，也是有利的。

### 1.1法律信息

例如，版权及著作权声明就是必须和有理由在每个源文件开头注释处放置的内容。

这类注释不应该是合同或法典。只要有可能，就指向一份标准许可或其他外部文档，而不要把所有条款放到注释中。

### 1.2阐释

有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。

### 1.3警示

用于警告其他程序员会出现某种后果的注释也是有用的。

### 1.4TODO注释

//TODO注释在源码中放置要做的工作列表。是一种程序员认为应该做，但由于某些原因目前还没做的工作。但是在最终版的代码中要删除这些注释。

### 1.5放大

注释可以用来放大某种看来不合理之物的重要性。

### 1.6公共API的javadoc

编写公共的API时，应该为它编写良好的javadoc。

## 2.坏的注释

### 2.1循规式注释

所谓每个函数都要有javadoc或每个变量都要有注释的规矩全然是愚蠢可笑的。

### 2.2日志式注释

有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。

例如某年某月某日修改了什么。

这种现在不需要了，因为有了git这种代码管理工具可以清楚的看到这些代码什么时候修改的，修改的原因。

### 2.3注释掉的代码

注释掉的代码应该删掉，需要回复的话可以从git中恢复。

### 2.4不要使用html格式的注释

这样会使得注释难以阅读。

# 格式

文件的长度200行最佳，最好不要超过500行，每行代码120个字符是上限，最好10-80个字符最佳

## 1.垂直格式

代码应该遵循从上往下从左到右的排列方式。

### 1.1向报纸学习

源文件应该像报纸那样。名称应当简单且一目了然。名称本身应该足够告诉我们是否在正确的模块中。源文件最顶部应该给出高层次概念和算法。细节应该往下渐次展开，直至找到源文件中最底层的函数和细节。

### 1.2概念间垂直方向上的区隔

每行展现一个表达式或一个句子，每组代码行展示一条完整的思路。这些思路用空白行区隔开来。

在封包声明、导入和每个函数之间，都应该有空白行隔开。

### 1.2垂直方向上的靠近

紧密相关的代码应该相互靠近。

### 1.3垂直距离

除非有很好的理由，否则不要把关系密切的概念放到不同的文件中。

变量声明，变量声明应尽可能靠近其使用位置。本地变量应该在函数的顶部出现。

实体变量（类的实例）应该在类的顶部声明

相关函数：若某个函数调用了另外一个，就应该把他们放在一起，而且调用者应该尽可能放在被调用者的上面。

概念相关：概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短。如assertFalse和assertTrue两个函数概念相关，就应该放在一起。

## 2.横向格式

### 2.1水平方向上的区隔与靠近

使用空格符将彼此紧密相关的事务连接到一起，也用空格字符把相关性较弱的事务分隔开。

### 2.2不需要水平对齐

### 2.3要有合适的缩进（四个空格符，不要用tab）

## 3.团队规则

每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。

# 对象和数据结构

## 1.数据抽象

不应该把对象中的数据直接暴露，而应该将对该对象允许的操作抽象成接口对外暴露

## 2.数据、对象的反对称性

对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。

可以在合适的情况下选择使用数据还是对象，但是绝大部分场景应该使用对象。

数据结构：如果给Geometry添加一个primeter（）函数，则那些形状类根本不会因此而受影响。但是如果新增一个形状类，那么就要修改所有的Geometry函数来处理新增的形状类。

![clip_image0011](picture\clip_image0011.png)

对象：如果新增一个形状类，其他形状类函数不会受到影响，但是如果需要增加一个方法时，则需要修改所有的形状类。

![clip_image0021](picture\clip_image0021.png)

## 3.得墨忒耳律（对于此规则认同度不高）

方法不应调用由任何函数返回的对象的方法。如以下错误示例

![clip_image0031](picture\clip_image0031.png)

它 调用 了 getOptions( )返回 值 的 getScratchDir( )函数， 又 调用 了 getScratchDir( )返回 值 的getAbsolutePath( )方法。

此类调用会引起火车失事，因为它看起来像一列火车，其中一个环节出现问题则之后的环节都会出事。

### 3.1隐藏结构

私有属性的访问器和改值器将内部接口暴露了，这样会使得该类称为半数据结构半对象。

修改建议：取消私有属性的访问器和取值器，将方法抽象提供接口。

# 错误处理

## 1.使用异常而不是错误码

## 2.先写Try-Catch-Finally语句

## 3.使用不可控异常

可控异常：在java中把那些可以预知的错误，例如从文件中读取数据，对数据库进行操作等，在程序编译时就能对程序中可能存在的错误进行处理，并给出具体的错误信息，我们把这些错误称为可控式异常。

运行时异常：在java中有些错误是不能被编译器检测到的，只有在运行的时候才能发现的异常称为运行时异常。

使用可控异常的问题：若在某一个大型系统的调用层级中，某个最底层的函数被修改为抛出一个异常。如果该异常是可控的，则函数签名就要添加throw子句。这意味着每个调用该函数的函数都要修改，捕获新异常，或在其签名中添加合适的throw子句。以此类推，最终得到的就是一个软件最低端贯穿到最高端的修改链。

自我感觉：可以在最底层中将异常处理掉，就不用修改全部的调用函数。

## 4.给出异常发生的环境说明

抛出异常的时候，应当提供足够的环境说明，以便判断错误的来源和所处。

应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。

## 5.依调用者需要定义异常类

如果在某个函数中需要捕获多个异常类，则将这个捕获异常的操作封装到一个方法中，将这些异常处理掉或者封装成自定义的异常抛出来。

将第三方API打包是个良好的实践手段。可以降低对第三方包的依赖。

## 6.不要在catch中写业务代码

## 7.别返回null值

## 8.别传递null值

# 边界

如何将外来代码干净利落的整合进自己的代码中。

## 1.使用第三方代码

第三方代码追求普适性，提供的接口多于我们需要的，而且第三方代码修改的时候我们的代码也需要同步修改，可以将第三方代码封装起来，隐藏我们用不到的接口，只暴露我们需要的接口，这样可以减少其他错误的操作，同时第三方代码修改的时候我们只需要修改我们封装的类就可以实现代码的适配。

（对于稳定性较好的第三方软件感觉没有太大的必要性）感觉没太大的必要性。

## 2.学习型测试

不要在生产代码中实验新东西，而是编写测试来遍览和理解第三方代码。

通过Junit编写测试类来学习第三方代码

## 3.对于未知的接口

![clip_image0012](picture\clip_image0012.png)

## 4.整洁的边界

边界上可能会发生很多意想不到的事，有良好设计的软件，无需巨大的投入和重写即可进行修改。在使用我们控制不了的代码时，必须加倍小心保护投资，确保未来的修改不至于代价太大。

此外边界上的代码需要清晰的分割和定义期望的测试。

# 单元测试

## 1.TDD三定律

一、在编写不能通过的单元测试前，不可编写生产代码

二、只可编写刚好无法通过的单元测试，不能变异的也算不通过

三、只可编写刚好足以通过当前失败测试的生产代码

## 2.保持测试代码整洁

测试代码应该包含之前几个章节的规则，确保测试代码的可读性，可维护性。

## 3.每个测试一个断言

每个测试也可以有多个断言，但是应该保持断言数量最小化

## 4.每个测试一个概念

## 5.FIRST规则

快速（Fast）：测试应该够快。

独立（Independent）：测试应该相互独立。

可重复（Repeatable）：测试应当在任何环境中重复通过。

自足验证（Self-Validating）：测试应该有布尔值输出。

及时（Timely）：测试应该及时编写。

# 类

## 1.类的组织

类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。

公共函数应跟在变量列表之后。我们喜欢把某个公共函数调用的私有工具函数紧随在该公共函数后面。符合自顶向下原则。

## 2.封装

最好保持变量和工具函数的私有性，但并不执着于此。必要的时候应该使用protected和public的变量和函数

## 3.单一权责原则

类或模块应有且只有一条加以修改的理由。如果有多个权责（要干的事情），就应该拆解该类。

## 4.内聚

类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。则内聚性就越高。

内聚性高意味着类中的方法和变量相互依赖、互相结合成一个逻辑整体。

## 5.隔离修改

若一个类依赖于外部TokyoStockExchange API的Portfolio类，其中TokyoStockExchange的API每五分钟就要修改一次，很难实现测试。

则可以创建一个StockExchange接口，其中只有一个方法。

![clip_image0041](picture\clip_image0041.png)

然后设计TokyoStockExchange来实现这个接口，同时确保Portfolio的构造器接受作为参数的StockExchange引用。

![clip_image0042](picture\clip_image0042.png)

实现隔离修改

![clip_image0043](picture\clip_image0043.png)



# 系统

在较高层级实现抽象--系统层级。

## 1.将系统的构造和使用分开

不要在使用的时候创建对象

### 1.1分解main（不理解）

将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中。

### 1.2工厂（不理解）

### 1.3依赖注入

例如spring中的容器

## 2.扩容（完全看不懂）

横贯式关注面

## 3.java代理（没看懂）

java代理适用于简单的情况，例如在单独的对象或类中包装方法调用。

## 4.纯java aop框架（没看懂）

## 5.AspectJ的方面（没看懂）

## 6.测试驱动系统架构

## 7.优化决策

延迟决策至最后一刻，允许我们基于最新的知识做出优化的、时机刚好的决策。决策的复杂性也降低了。

## 8.明智使用添加了可论证价值的标准

例如使用spring还是EJB2

## 9.系统需要领域特定语言

领域特定语言（DomainSpecific Language，DSL），DSL是一种单独的小型脚本语言或以标准语言写就的API，领域专家可以用它编写读起来像是组织严谨的散文一样的代码。例如java。

# 迭进

## 1.通过迭进设计达到整洁目的

据Kent所述，只要遵循以下规则，设计就能变得简单：

运行所有测试

不可重复

表达了程序员的意图

尽可能减少类和方法的数量

以上规则按其重要程度排列

## 2.运行所有测试

全面测试并持续通过所有测试的系统，就是可测试的系统。不可测试的系统同样不可验证。不可验证的系统，绝不部署。

遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近丢合度、高内聚度的目标。

## 3.简单设计规则2-4：重构

有了测试就可以通过递增式地重构代码来保持代码和类的整洁。

步骤：修改一个类或方法，思索是否优于之前的代码，若优于则保留，否则删除，运行测试，保证没有破坏任何东西。测试消除了对清理代码就会破坏代码的恐惧。

重构目的：消除重复，保证表达力，尽可能减少类和方法的数量。

# 并发编程

并发编程很难

并发会在性能和编写额外代码上增加一些开销

正确的并发是复杂的，即便对于简单的问题也是如此

并发缺陷并非总能重现，所以常被看做偶发事件忽略，未被当做真的缺陷看待

并发常常需要对设计策略进行根本性修改

之后阅读java并发编程继续深入学习