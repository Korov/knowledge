# 1 简介

线程是CPU调度的基本单位。

# 2 线程安全性

在构建稳健的并发程序时，必须正确地使用线程和锁。但这些终归只是一些机制。要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronize，它提供了一种独占的加锁方式，单**同步**这个术语还包括volatile类型的变量，显示锁以及原子变量。

**有时候，面向对象中的抽象和封装会降低程序的性能，但在编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度。**

## 2.1 什么是线程安全性

当多个线程访问某个类时，这个类始终都嗯呢该表现出正确的行为，那么就称这个类时线程安全的。

无状态对象（它既不包含任何域，也不包含任何对其他类中域的引用）一定是线程安全的。

## 2.2 原子性

在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，被称为竞态条件。

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。

## 2.3 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视锁。线程在进入同步代码块之前会自动获得锁，并且在推出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁。

## 2.4 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是线程，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1.如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为0时，这个锁将被释放。

## 2.5 用锁来保护状态

一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此。对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

**每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。**

一种常见的枷锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

## 2.5 活跃性和性能

被锁锁定的代码块越少则线程的并发性越高，但是锁定的代码太少有可能导致频繁的线程切换问题，导致性能损耗。

**通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能破坏安全性）**

当执行计算密集的操作，或者某个可能阻塞的操作，若果持有锁的时间过长，那么都会带来活跃性或性能问题。

# 3 对象的共享

同步除了用于实现原子性或者确定“临界区”，还有另一个重要的方面：内存可见性。当某个线程正在使用对象状态而另一个线程在同时修改该状态，并且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。同步可以实现。

## 3.1 可见性

### 3.1.1 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。

最低安全性适用于绝大多数便令，但存在一个例外：非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读写操作分解为两个32位的操作。当读取一个非volatile类型的变量时，如果对该变量的读操作写写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。

### 3.1.2 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果，当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。

**加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。**

### 3.1.3 Volatile变量

当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会讲该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会放回最新写入的值。

## 3.2 发布与逸出

发布（Publish）一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出（Escape）。

发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。当发布某个对象时，可能会间接地发布其他对象。例如发布的对象A中有B对象的引用。

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用达到其他的对象，那么这些对象也都会被发布。

**安全的对象构造过程**：如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。因此不要在构造过程中让this引用逸出。