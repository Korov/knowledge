# 1 简介

线程是CPU调度的基本单位。

# 2 线程安全性

在构建稳健的并发程序时，必须正确地使用线程和锁。但这些终归只是一些机制。要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作，必须采用同步机制来协同这些线程对变量的访问。Java中的主要同步机制是关键字synchronize，它提供了一种独占的加锁方式，单**同步**这个术语还包括volatile类型的变量，显示锁以及原子变量。

**有时候，面向对象中的抽象和封装会降低程序的性能，但在编写并发应用程序时，一种正确的编程方法就是：首先使代码正确运行，然后再提高代码的速度。**

## 2.1 什么是线程安全性

当多个线程访问某个类时，这个类始终都嗯呢该表现出正确的行为，那么就称这个类时线程安全的。

无状态对象（它既不包含任何域，也不包含任何对其他类中域的引用）一定是线程安全的。

## 2.2 原子性

在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，被称为竞态条件。

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。

## 2.3 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视锁。线程在进入同步代码块之前会自动获得锁，并且在推出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁。

## 2.4 重入

当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是线程，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1.如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为0时，这个锁将被释放。

## 2.5 用锁来保护状态

一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此。对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

**每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。**

一种常见的枷锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

## 2.5 活跃性和性能

被锁锁定的代码块越少则线程的并发性越高，但是锁定的代码太少有可能导致频繁的线程切换问题，导致性能损耗。

**通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能破坏安全性）**

当执行计算密集的操作，或者某个可能阻塞的操作，若果持有锁的时间过长，那么都会带来活跃性或性能问题。

# 3 对象的共享

同步除了用于实现原子性或者确定“临界区”，还有另一个重要的方面：内存可见性。当某个线程正在使用对象状态而另一个线程在同时修改该状态，并且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。同步可以实现。

## 3.1 可见性

### 3.1.1 非原子的64位操作

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。

最低安全性适用于绝大多数便令，但存在一个例外：非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读写操作分解为两个32位的操作。当读取一个非volatile类型的变量时，如果对该变量的读操作写写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。

### 3.1.2 加锁与可见性

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果，当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。

**加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。**

### 3.1.3 Volatile变量

当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会讲该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会放回最新写入的值。

## 3.2 发布与逸出

发布（Publish）一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出（Escape）。

发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。当发布某个对象时，可能会间接地发布其他对象。例如发布的对象A中有B对象的引用。

当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用达到其他的对象，那么这些对象也都会被发布。

**安全的对象构造过程**：如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。因此不要在构造过程中让this引用逸出。

## 3.3 线程封闭

数据仅在单线程中被访问，即数据不共享。线程封闭式是实现线程安全的最简单的方式之一。

### 3.3.1 Ad-hoc线程限制

指维护线程限制性的任务全部落在实现上的这种情况。因为没有可见性修饰符与本地变量等语言特性协助将对象限制在目标线程上，所以这种方式非常容易出错。

### 3.3.2 栈限制

栈限制是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。

### 3.3.3 ThreadLocal

更加规范的线程限制方式。它允许你将每个线程与持有数值的对象关联在一起。ThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝。所以get总是返回由**当前执行线程**通过set设置的最新值。

ThreadLocal变量通常用于防止在基于可变的单体（Singleton）或全局变量的设计中，出现共享。

这项技术还用于下面的情况：一个频繁执行的操作既需要像buffer这样的临时对象，同时还需要避免每次都重分配该临时对象。实现一个应用程序框架会广泛地使用ThreadLocal。

# 4 对象的组合

### 4.2.1 java监视器模式

遵循java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。

## 4.3 线程安全性的委托

大多数对象都是组合对象。当从头开始构建一个类，或者将多个非线程安全的类组合为一个类时，Java监视器模式是非常有用的。但是，如果类中的各个组件都已经是线程安全的，我们是否需要再增加一个额外的线程安全层，这需要视情况而定。在某些情况下，通过多个线程安全类组合而成的类是线程安全的。

# 5 基础构建模块

## 5.1 同步容器类

同步容器类包括Vector和Hashtable。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。

### 5.1.1 同步容器类的问题

同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代、跳转以及条件运算在没有客户端加锁的情况下仍然是线程安全的。其他情况就有可能出现意料之外的行为。

Vector容器在获取数组长度的时候并没有加锁，此时获取的长度有可能是错误的，导致出现意想不到的结果。迭代器也是，当一边迭代一边并发修改的时候就可能出现错误。

### 5.1.2 隐藏迭代器

对所有共享容器进行迭代的地方都需要加锁，但是有部分迭代器会隐藏起来，要仔细排查。

容器的hashCode和equals等方法也会间接地执行迭代操作，containsAll、removeAll等方法也会隐藏调用迭代器。

## 5.2 并发容器

同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。

并发容器是针对多个线程并发访问设计的。**通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。**

### 5.2.1 ConcurrentHashMap

ConcurrentHashMap与HashMap一样是一个基于散列的Map，但它使用了一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁（Lock Striping）。在这种机制中，任意数量的**读取**线程可以并发地访问Map，执行**读取操作**的线程和执行**写入操作**的线程可以并发地访问Map，并且**一定数量的写入线程**可以并发地修改Map。其结果是在并发访问环境下将实现更高的吞吐量，而在单线程环境中只损失非常小的性能。

ConcurrentHashMap提供的迭代器不会抛出ConcurrentModificationException，因此不需要子迭代过程中对容器加锁。其迭代器具有弱一致性，而非及时失败。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。

### 5.2.2 额外的院子Map操作

ConcurrentHashMap不能被加锁来执行独占访问。可以使用ConcurrentMap来实现相应的功能。

### 5.2.3 CopyOnWriteArrayList

用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。（类似的，CopyOnWriteArraySet用于替代同步Set）。

其线程安全性在于，只要正确的发布一个事实不可变的对象，那么在访问该对象时就不需要进一步同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。写入时复制容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需要确保数组内容的可见性。但是每次修改都会复制底层数组，所以应谨慎使用。

## 5.3 阻塞队列和生产者-消费者模式

阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果对垒已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远都不会充满，因此无限队列上的put方法也永远不会阻塞。offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。

**有界队列是强大的资源管理工具，用来建立可靠的应用程序：他们遏制那些可以产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮**

## 5.4 阻塞和可中断的方法

线程可能会因为几种原因呗阻塞或暂停：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep中唤醒，或者是等待另一个线程计算结果。当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态。

中断是一种协作机制。一个线程不能够迫使其他线程停止正在做的事情，或者去做其他事情当线程A中断B时，A仅仅是要求B在达成某个方便停止的关键点时，停止正在做的事情。

当你在代码中调用了一个会抛出InterruptedException的方法时，你自己的方法也成为了一个阻塞方法，要为响应中断做好准备。两种基本的处理中断方法：

- 传递InterruptedException，将异常传递给调用让他去处理
- 恢复中断：捕获异常并在当前线程中通过调用interrupt从中断恢复。

## 5.5 Synchronizer

Synchronizer是一个对象，它根据本身的状态调节线程的控制流。阻塞队列可以扮演一个Synchronizer的角色；其他类型的Synchronizer包括信号量（semaphore）、关卡（barrier）以及闭锁（latch）。

所有Synchronizer都享有类似的结构特性：他们封装状态，而这些状态决定着线程执行到某一点时是通过还是被迫等待；他们还提供操控状态的方法，以及高效的等待Synchronizer进入到期望状态的方法。

### 5.5.1 闭锁

闭锁是一种Synchronizer，它可以延迟线程的进度直到线程到达终止状态。一个闭锁工作起来就像一道大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，允许所有线程都通过。一旦闭锁到达了终点状态，它就不能够再改变状态了，所以它永远保持敞开状态。

CountDownLatch是一个灵活的闭锁实现，允许一个或多个线程等待一个事件集的发生。闭锁的状态包括一个计数器，初始化为一个正数，用来表现需要等待的事件数。countDown方法对计数器做减操作，表示一个事件已将发生了，而await方法等待计数器达到零，此时所有需要等待的事件都已发生。如果计数器入口值为非零，await会一直阻塞直到计数器为零，或者等待线程中断以及超时。

```java
public class TestHarness {
    public long timeTasks(int threadNumber, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(threadNumber);
        for (int i = 0; i < threadNumber; i++) {
            Thread thread = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };
            thread.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
        System.out.printf("Task start\n");
        endGate.await();
        long end = System.nanoTime();
        System.out.printf("Time is: %s\n", end - start);
        return end - start;
    }
}
```

TestHarness阐释了闭锁的两种常见用法。TestHarness创建了一些线程，并发地执行给定的任务。它使用两个闭锁，一个**开始阀门**和一个**结束阀门**。开始阀门将计数器初始化为1.结束阀门将计数器初始化为工作线程的数量。每个工作线程要做的第一件事情就是等待开始阀门打开；这样做能确保直到所有线程都做好准备时才开始工作。每个线程的最后一个工作是为结束阀门减一，这样做使控制线程有效的等待，直到最后一个工作线程完成任务。

### 5.5.2 FutureTask

FutureTask同样可以作为闭锁。FutureTask实现描述了一个抽象的可携带结果的计算。FutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable，并且有3个状态：等待、运行和完成。包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。

Future.get的行为依赖于任务的状态。如果它已经完成，get可以立刻得到返回结果，否则会被阻塞直到任务转入完成状态，然后返回结果或抛出异常。FutureTask把计算的结果从运行计算的线程传送到需要这个结果的线程；FutureTask的规约保证了这种传递建立在结果的安全发布基础之上。

Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时计算，而且可以在真正需要计算结果之前就启动他们开始计算。

```java
public class PreLoader {
    ProductInfo loadProductInfo() {
        System.out.printf("ProductInfo is loading!\n");
        ProductInfo productInfo = new ProductionInfo(Thread.currentThread().getName());
        return productInfo;
    }

    private final FutureTask<ProductInfo> futureTask = new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
        @Override
        public ProductInfo call() throws Exception {
            return loadProductInfo();
        }
    });
    private final Thread thread = new Thread(futureTask);

    public void start() {
        thread.start();
    }

    public ProductInfo get() throws InterruptedException {
        try {
            return futureTask.get();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

Preloader创建了一个FutureTask，其中包含充数据库加载产品信息的任务，以及一个执行运算的线程。由于构造函数或静态初始化方法中启动线程并不是一个好方法，因此提供一个start方法来启动线程。当程序随后需要ProductInfo时，可以调用get方法，如果数据已经加载，那么将返回这些数据，否则将等待加载完成后再返回。

### 5.5.3 信号量

计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

Semaphore中管理者一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可，并在使用后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用作互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。

可以使用Semaphore实现资源池，计数值初始化为池的大小，当获取一个线程时acquire，用完之后release。也可以使用Semaphore将任何一种容器变成有界阻塞容器。

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore semaphore;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<>());
        semaphore = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        semaphore.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded) {
                semaphore.release();
            }
        }
    }

    public boolean remove(T o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved) {
            semaphore.release();
        }
        return wasRemoved;
    }
}
```

### 5.5.4 栅栏

栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集，它在并行迭代算法中非常有用。这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrierException。如果成功的通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来选举产生一个领导线程，并在下一次迭代中由该领到线程执行一些特殊的工作。