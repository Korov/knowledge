介绍自己；

各位面试官好，我叫朱磊，毕业于广西大学信息管理与信息系统专业，2018年7月至2019年11月就职于中软国际，职能是作为SmartNDP WEB项目中链路模块的主要负责人，主要职责是保证链路模块整体功能的正常迭代，以及链路整个模块的框架的可维护性。技术方面熟悉java，mysql，spring，redis，kafka，git，maven。

自己的项目经验；



# 1 Spring

## 1.1 Spring bean的生命周期

首先是实例化bean，然后将bean的各种引用注入到bean中，如果实现了某些指定的接口，则会调用这些接口中要求实现的方法，之后就是使用bean，最后销毁bean。

## 1.2 SpringMVC，其处理流程

![image-20191116183355508](picture\image-20191116183355508.png)

1. 发起请求到前端控制器（DispatcherServlet）
2. 前端控制器请求HandlerMapping查找Handler（可以根据XML配置、注解进行查找）
3. 处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为 HandlerExecutionChain对象（包含一个Handler处理器（页面控制）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略
4. 前端控制器调用处理器适配器去执行Handler
5. 处理器适配器HandlerAdapter将会根据适配的结果去执行Handler
6. Handler执行完成给适配器返回ModelAndView
7.  处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）
8.  前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 
9.  视图解析器向前端控制器返回View 
10.  前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 
11.  前端控制器向用户响应结果 

首先用户发送请求到前端控制器，前端控制器根据请求信息去处理器映射器中找到相应的处理器，然后调用处理器适配器执行这个处理器，处理完成后获得一个ModelAndView，接着调用试图解析器和试图渲染器最终生成用户界面返回给用户。

## 1.3 SpringMVC怎么样设定重定向和转发

转发在返回值前面加forward，重定向在返回值前面加redirect。

## 1.4 springmvc怎么和ajax相互调用

通过jackson或者其他框架吧java里面的对象直接转化成json对象

## 1.5 sprinmvc中中文乱码

post乱码可以在web.xml中配置一个CharacterEncodingFilter过滤器。

get乱码：对参数进行重新编码，或者在tomcat配置文件中修改编码与项目的编码一致。

## 1.6 怎么样从springmvc中得到request或者session

直接在方法的形参中声明HttpServletRequest，springmvc就会自动把request对象传入。

## 1.7 怎么样把ModelMap里面的数据放入Session中

可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key

# 2 Java

## 2.2 jvm加载类过程

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

## 2.3 HashCode的作用

hashcode是根据对象内容生成的一串编码，这串编码的作用就是辅助判断对象是否相等。

## 2.4 session和cookie的区别

cookie以文本格式存储在浏览器上，存储量有限；session存储在服务端，可以无限量存储多个变量并且比cookie更安全

## 2.5 JVM/GC

GC收集算法：标记-清除算法，复制算法，标记-整理算法，分代收集算法

## 2.6 Java基类Object类

所有类的父类，其中方法有equal，hashcode，toString ,clone，wait和notify，notifyAll。

## 2.7 引用

强引用：使用最普遍的引用，一般情况下，垃圾回收器绝对不会回收它。内存不足时，抛出OOM。软引用：内存空间足够，垃圾回收器不会回收它。反之，则回收。适用于缓存，而且不会OOM。弱引用：只有当垃圾回收器扫描到弱引用指向的对象时，才会回收它。生命周期比软引用更短。ThreadLocal的key使用了弱引用。虚引用：在任何时候都可能被垃圾回收器回收，必须与引用队列关联使用。

## final和static关键字的作用

final修饰类中的属性或变量，该属性或变量必须在构造函数执行完毕之前完成初始化。final修饰的变量的值不可以改变。final修饰的方法可以被继承不可以被重写。final修饰的类不可以被继承。

static修饰的方法可以不通过本类的对象即可调用，static修饰的变量为全局变量，所有的类共享该变量。只有内部类才可以用static修饰。

## java 中操作字符串都有哪些类？它们之间有什么区别？

- String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。
- StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。
- StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。

## 抽象类和普通类有那些区别？

- 抽象类不恩嗯被实例化
- 抽象类可以没有抽象方法，有抽象方法的类必须被声明为抽象类，抽象方法只需要声明，无需实现
- 抽象类的子类必须实现抽象类中的抽象方法，否则这个子类也是抽象类
- 抽象方法不恩嗯被声明为静态，不能用private，static和final修饰

## 抽象类和接口的区别

1. 抽象类和接口都不能被实例化
2. 抽象类被继承，接口被实现，单继承多实现
3. 接口只能声明方法，而抽象类中可以声明方法也可以实现方法
4. 抽象类中的抽象方法必须由子类全部实现，否则这个子类也是抽象类。接口中的方法必须由实现类全部实现，否则这个类就是一个抽象类
5. 接口里的方法只能声明，不能有具体的实现，这说明接口是设计的结果，抽象类时重构的结果

## java 中 IO 流分为几种

字节流和字符流，分别由四个抽象类来表示。字节流的输入输入：InputStream，OutputStream。字符流的输入输出：Reader，Writer。

读取文本的时候使用字符流，可以直接读取，用字节流的话还需要转换。其他文件的读取使用字节流。

## BIO、NIO、AIO 有什么区别？

BIO：Block IO同步阻塞式IO，并发处理能力低。线程发起IO请求，不管内核是否准备好IO操作，从发起请求，线程一直阻塞，直到操作完成

NIO：Non IO同步非阻塞IO，客户端和服务端通过Channel（通道）通讯，实现了多路复用。线程发起IO请求，立即返回；内核在做好IO操作的准备后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。

AIO：Asynchronous IO异步非阻塞IO。线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做的IO操作完成或失败。

- BIO是一个连接一个线程。
- NIO是一个请求一个线程。
- AIO是一个有效请求一个线程。

## java容器有哪些

Collection和Map两个

|Collection
 |　　├List
 |　　│-├LinkedList
 |　　│-├ArrayList
 |　　│-└Vector
 |　　│　└Stack
 |　　├Set
 |　　│├HashSet
 |　　│├TreeSet
 |　　│└LinkedSet
 |
 |Map
 　├Hashtable
 　├HashMap
 　└WeakHashMap

**同步容器**：Vector，Stack，HashTable，Collections.synchronized方法生成

**并发容器**：

- ConcurrentHashMap：线程安全的HashMap实现
- CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayList
- CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素
- ArrayBlockingQueue：基于数组，先进先出，线程安全，可实现制定时间的阻塞读写，并且数量可以限制
- LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下性能优于ArrayBlockingQueue。

## HashMap和HashTable有什么区别

**线程安全性不同**：Hashtable是线程安全的，HashMap不是线程安全的

**继承的父类不同**：HashMap继承AbstractMap类，Hashtable继承Dictionary类，但是他们都实现了Map、Cloneable和Serializable接口。

**对外提供的接口不同**：Hashtable比HashMap多提供了elments()和contains()两个方法，elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

**对null key和null value的支持不同**：Hashtable既不支持Null key也不支持Null value。HashMap可以有一个null key，多个null value。

**遍历方式不同**：Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

**初始容量和每次扩充大小不同**：Hashtable默认的初始大小是11,之后每次扩充容量变为原来的2n+1，。HashMap默认初始大小为16,每次扩充容量变为原来的2倍。创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。

**计算hash值的方法不同**：Hashtable直接使用对象的hashCode，HashMap会重新根据hashcode计算hash值。

## HashMap的实现

HashMap是基于拉链法实现的一个散列表，内部由数组、链表和红黑树实现。

 ![img](picture\1216080-20180412104426360-1425516709.png)

HashMap的工作原理：

1. 数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)
2. 数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。
3. 为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能，这里是一个平衡点。
4. 对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。

**数组的索引bucket**：HashMap采用hash算法来决定集合中元素的存储位置，每当系统初始化HashMap时，会创建一个为`capacity`的数组，这个数组里面可以存储元素的位置被成为`桶(bucket)`, 每个`bucket`都有其指定索引。可以根据该索引快速访问存储的元素。

### 2.1.2 存在有序的HashMap吗？

TreeMap和LinkedHashMap。TreeMap默认是按照key值升序排序的，用红黑树作为实现的，可以使用比较器改变排序。LinkedHashMap是按照put的顺序排序的。

### 2.1.3 你有更好的实现有序Map的方法吗？

B+树

### 2.1.4 我们能否让HashMap同步

Map m = Collections.synchronizeMap(hashMap);

## 2.1.5 你知道HashMap的put()方法和get()方法的工作原理吗

put：

1. 检查数组是否为空，执行resize()扩充
2. 通过hash值计算数组索引，获取该索引位的首节点
3. 如果首节点为null`（没发生碰撞）`，直接添加节点到该索引位`(bucket)`
4. 如果首节点不为null`（发生碰撞）`，那么有3种情况：① key和首节点的key相同，覆盖old value`（保证key的唯一性）`；否则执行②或③；② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。③ 如果首节点是链表，将键值对添加到链表。添加之后会判断链表长度是否到达。TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。
5. 最后判断当前元素个数是否大于threshold，扩充数组

get：

1. 检查数组是否为null 和 索引位首节点`(bucket的第一个节点)`是否为null
2. 如果索引节点的hash==key的hash 或者 key和索引节点的k相同则直接返回`(bucket的第一个节点)`
3. 如果是红黑色则到红黑树查找
4. 如果有冲突，则通过key.equals(k)查找
5. 都没找到就返回null

## 2.1.6 当两个对象的hashcode相同会发生什么

两个对象的hashCode相同所以它们的bucket位置相同，会发生hash碰撞。HashMap使用链表存储对象，这个Entry会存储在链表中，存储时会检查链表中是否包含key `(key != null && key.equals(k)`，或将键值对添加到链表尾部。如果链表长度大于或等于8，链表转换红黑树

## 2.1.7 如果两个键的hashcode相同，如何获取对象值

两个对象的hashCode相同所以它们的bucket位置相同，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点 `(key != null && key.equals(k)`

## 2.1.8 影响HashMap性能的因素

负载因子，哈希值。

## 2.1.9 HashMap为什么只允许一个key为null

如果key为null，会放在第一个bucket位置，而且是在链表最前面。

## 如何实现数组和 List 之间的转换

1. 遍历数组然后add进list
2. 使用Arrays.asList
3. Collections.addAll()
4. 使用Stream中的Collector收集器

## ArrayList和Vector区别

两个都实现了List接口，继承了AbstractList类。Vector是线程安全的。都使用数组实现。vector的扩充为2n，ArrayList扩充为原来的1.5n。

## Queue中的方法

**offer()和add()的区别**：add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。

**peek()和element()的区别**：peek()和element()都将在**不移除**的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。

**poll()和remove()的区别**：poll()和remove()都将**移除**并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。

## Iterator有什么特点

1. Iterator遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出ConcurrentModificationEception的异常。
2. Iterator遍历集合元素的过程中可以通过remove方法来移除集合中的元素。
3. Iterator必须依附某个Collection对象而存在，Iterator本身不具有装载数据对象的功能。
4. Iterator.remove方法删除的是上一次Iterator.next()方法返回的对象。调用remove时必须先调用next
5. 强调以下next（）方法，该方法通过游标指向的形式返回Iterator下一个元素。

## Iterator 和 ListIterator 有什么区别

1. ListIterator有add()方法，可以向list中添加对象
2. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。
3. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
4. ListIterator可以通过set方法实现对象的修改，Iterator不可以

## 怎么确保一个集合不能被修改

```java
Collections.unmodifiableList(List);
Collections.unmodifiableMap(List);
Collections.unmodifiableSet(List);
```



## 2.8 线程与进程之间的不同

进程是资源分配的最小单位，线程是程序执行的最小单位，每个进程有自己的独立地址空间，线程共享进程中的数据。

## 2.9 Thread类中的start和run方法有什么区别

start被用来启动新线程并且在内部调用了run，run不能。start不能被重复调用，run可以。

## 2.10 在多线程中，什么是上下文切换

存储和恢复CPU状态的过程，它使得线程能够从中断点恢复。

## 2.11 volatile变量

一种实现数据共享的轻量锁，被volatile修饰的变量不会被重排序，并且修改和获取的时候都是在主内存中进行的，不是在线程私有的内存中进行的。

## 2.12 死锁是什么？如何避免死锁？

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

死锁发生的四个条件：

- 互斥条件：一个资源每次只能被一个线程使用
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系

避免死锁最简单的方法及时阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁。

## 2.13 Thread类中的yield方法有什么作用

Thread.yield()方法会使当前线程从运行状态变为就绪状态，把运行机会让给其他相同优先级的线程。

## 2.14 Java中interrupted 和 isInterruptedd方法的区别

interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态。isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态。

```Java
public class ThreadTest {
    public static void main(String[] args) {
        // 调用interrupt将线程中断状态设置为true
        Thread.currentThread().interrupt();
        System.out.println(Thread.currentThread().isInterrupted());
        System.out.println(Thread.interrupted());
        // 线程中断状态被interrupted重置为false
        System.out.println(Thread.currentThread().isInterrupted());
    }
}

true
true
false
```

## 2.15 Java多线程中调用wait() 和 sleep()方法有什么不同

sleep()和wait()都是使线程暂停执行一段时间的方法。区别：

1. 原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。而wait()方法是Object类的方法，用于线程间的通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程用调用notify()或notifyAll()时才苏醒过来，开发人员也可以给它指定一个时间使其自动醒来
2. 对锁的处理机制不同：由于sleep()方法的主要作用是让线程暂停一段时间，时间一到则自动恢复，不涉及线程间的通信，因此调用sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。
3. 使用区域不同：wait()方法必须放在同步控制方法或者同步语句块中使用，而sleep方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。

由于sleep不会释放锁标志，容易导致死锁问题的发生，一般情况下，不推荐使用sleep()方法，而推荐使用wait()方法。

## 2.16 守护线程

在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 
 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程

## 2.17 java thread状态

- new：初始状态，线程刚创建，尚未启动
- runnable：运行状态，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）
- blocked：阻塞状态，线程阻塞于锁
- waiting：等待状态，进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
- timed_waiting：超时等待，该状态不同于WAITING，它可以在指定的时间后自行返回
- terminated：终止，表示该线程已经执行完毕

## 2.18 进程调度算法

**实时系统**：FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。  
 **交互式系统**：RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。

## 2.19 synchronized与lock和volatile区别

synchronized与volatile区别：
- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

synchronized与lock区别：
- 首先synchronized是java内置关键字，在jvm层面，Lock是个java类
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
- synchronized会自动释放锁，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可），（公平锁是指多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁）
- ock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题
- synchronized可以给类、方法、代码块加锁，而lock只能给代码块加锁。

## 说一下 atomic 的原理

自旋 + CAS（乐观锁）。在这个过程中，通过compareAndSwapInt比较更新value值，如果更新失败，重新获取旧值，然后更新



## 2.20 四种常见线程池以及ThreadPoolExecutor

jdk1.8线程池种类：newFixedThreadPool（定长线程池），newCachedThreadPool（可缓存线程池），newScheduledThreadPool（定长线程池，可执行周期性任务），newSingleThreadExecutor（单线程，线程池），newSingleThreadScheduledExecutor（单线程可执行周期性任务线程池），newWorkStealingPool（任务窃取线程池，不保证执行顺序，适合任务耗时差异较大。线程池中有多个线程队列，有的线程队列中有大量的比较耗时的任务堆积，而有的线程队列却是空的，就存在有的线程处于饥饿状态，当一个线程处于饥饿状态时，它就会去其它的线程队列中窃取任务。解决饥饿导致的效率问题）
ThreadPoolExecutor四种线程池就是通过此类的构造方法实现的。设置核心线程数量，线程存活时间，线程池可以容纳的最大线程数。线程池中的任务队列三种：SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。

## 线程池有哪些状态

1. RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0
2. SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。调用线程池的shutdown()方法时，线程池由RUNNING -> SHUTDOWN。
3. STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -> STOP。
4. TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。
5. TERMINATED：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

## 线程池的submit和execute方法区别
线程池中的execute方法大家都不陌生，即开启线程执行池中的任务。还有一个方法submit也可以做到，它的功能是提交指定的任务去执行并且返回Future对象，即执行的结果。
- 接收参数不一样：execute() 参数 Runnable ；submit() 参数 (Runnable) 或 (Runnable 和 结果 T) 或 (Callable)
- 返回值不一样：execute() 没有返回值；而 submit() 有返回值
- submit() 的返回值 Future 调用get方法时，可以捕获处理异常

## java 程序中怎么保证多线程的运行安全

保证三要素：
- 原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性
- 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到
- 有序性：程序执行的顺序按照代码的先后顺序执行

## 多线程锁的升级原理是什么

锁的级别：无锁->偏向锁->轻量级锁->重量级锁
锁分级别的原因：没有优化前，sychroniezed是重量级锁（悲观锁），使用wait、notify、notifyAll来切换线程状态非常消耗系统资源，线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以JVM对sychronized关键字进行了优化，把锁分为无锁、偏向锁、轻量级锁、重量级锁

- 无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其它修改失败的线程会不断重试直到修改成功。
- 偏向锁：对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停偏向锁的线程，然后判断锁对象是否处于被锁定状态，如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁。如果线程处于活动状态，升级为轻量级锁的状态。
- 轻量级锁：轻量级锁是指当锁是偏向锁的时候，被第二个线程B访问，此时偏向锁就会升级为轻量级锁，线程B会通过自旋的形式尝试获取锁，线程不会阻塞，从未提升性能。当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定次数时，轻量级锁边会升级为重量级锁，当一个线程已持有锁，另一个线程在自旋，而此时第三个线程来访时，轻量级锁也会升级为重量级锁。（自旋（spinlock）是指当一个线程获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。）
- 重量级锁：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。重量级锁通过对象内部的监听器（monitor）实现，而其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

## ThreadLocal是什么？有哪些使用场景？

ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。

经典的使用场景是为每个线程分配一个 JDBC 连接Connection。这样就可以保证每个线程的都在各自的 Connection上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有Session 管理 等问题。

## synchronized底层实现原理
jvm基于进入和退出Monitor对象来实现方法同步和代码块同步。
方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。
代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。
这里要注意：

synchronized是可重入的，所以不会自己把，自己锁死
synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞

## 2.21 Executor拒绝策略

1. AbortPolicy:为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try 
    catch，否则程序会直接退出.
2. DiscardPolicy:直接抛弃，任务不执行，空方法
3. DiscardOldestPolicy:从队列里面抛弃head的一个任务，并再次execute 此task。
4. CallerRunsPolicy:在调用execute的线程里面执行此command，会阻塞入
5. 用户自定义拒绝策略:实现RejectedExecutionHandler，并自己定义策略模式 

## 2.22 CopyOnWriteArrayList

CopyOnWriteArrayList :  写时加锁，当添加一个元素的时候，将原来的容器进行copy，复制出一个新的容器，然后在新的容器里面写，写完之后再将原容器的引用指向新的容器，而读的时候是读旧容器的数据，所以可以进行并发的读，但这是一种弱一致性的策略。  
 使用场景：CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。

## 2.23 java里的阻塞队列

ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。   LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 
 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。   DelayQueue：一个使用优先级队列实现的无界阻塞队列。   SynchronousQueue：一个不存储元素的阻塞队列。   LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。   LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

## 2.24 Fork/Join框架

## 2.25 原子操作类

## 2.26 栅栏，闭锁，信号量

## 2.27 进程间通信方式

1. 管道
2. 有名管道
3. 信号量
4. 消息队列
5. 信号
6. 共享内存
7. 套接字

## 2.28 并发和并行的区别

并发：同一时间段，多个任务都在执行，单位时间内不一定同时执行;并行：单位时间内，多个任务同时执行。

## 2.29 创建线程有哪几种方式

继承Thread类创建线程，实现Runnable接口创建线程，实现Callable接口创建线程

## 2.30 说一下 runnable 和 callable 有什么区别

相同：两者都是接口，两者都可用来编写多线程程序，都通过Thread.start()启动线程
不同：实现Callable接口的任务线程能返回执行结果，实现Runnable接口的任务线程不能返回结果；Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛。
注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞

## 什么是反射

是指程序在运行状态中，对于任意一个类，都可以知道这个类的所有属性和方法；对于任意一个对象，都能够调用他的任意方法和属性。
其原理是通过类的全限定名加载class文件，然后通过class文件创建一个完整的对象。

## 什么是 java 序列化？什么情况下需要序列化？

序列化：将JAva对象转换成字节流。反序列化：将字节流转换成Java对象的过程。

当Java对象需要在网络上传输或者持久化存储到文件中时，就需要使用序列化

注意：
1. 某个类可以被序列化，则其子类也可以被序列化
2. 声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据
3. 反序列化读取序列化对象的顺序要保持一致

## 什么是动态代理？动态代理是如何实现的？动态代理有哪些应用？

动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。
动态代理实现：首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。
动态代理的应用：Spring的AOP，加事务，加权限，加日志。

## 如何实现克隆

实现Cloneable接口，并重写object类中的clone方法可以实现浅克隆。
实现Serializable，通过对象的序列化和反序列化实现正真的深克隆。

# Java Web

## jsp和servlet有什么区别

Servlet：
- 一种服务器端的Java应用程序
- 由 Web 容器加载和管理
- 用于生成动态 Web 内容
- 负责处理客户端请求

Jsp:
- 是 Servlet 的扩展，本质上还是 Servlet
- 每个 Jsp 页面就是一个 Servlet 实例
- Jsp 页面会被 Web 容器编译成 Servlet，Servlet 再负责响应用户请求

区别:
- Servlet 适合动态输出 Web 数据和业务逻辑处理，对于 html页面内容的修改非常不方便；Jsp 是在 Html 代码中嵌入 Java 代码，适合页面的显示
- 内置对象不同，获取内置对象的方式不同

## Jsp有哪些内置对象？作用分别是什么？

Page，pageContext，request，response，session，application，out，config，exception
Page指的是JSP被翻译成Servlet的对象的引用.
pageContext对象可以用来获得其他8个内置对象,还可以作为JSP的域范围对象使用.pageContext中存的值是当前的页面的作用范围》
request代表的是请求对象,可以用于获得客户机的信息,也可以作为域对象来使用，使用request保存的数据在一次请求范围内有效。
Session代表的是一次会话，可以用于保存用户的私有的信息,也可以作为域对象使用，使用session保存的数据在一次会话范围有效
Application：代表整个应用范围,使用这个对象保存的数据在整个web应用中都有效。
Response是响应对象,代表的是从服务器向浏览器响应数据.
Out:JSPWriter是用于向页面输出内容的对象
Config：指的是ServletConfig用于JSP翻译成Servlet后 获得Servlet的配置的对象.
Exception:在页面中设置isErrorPage=”true”，即可使用，是Throwable的引用.用来获得页面的错误信息。

## Jsp的四种作用域
page:代表页面上下文，范围是一个页面及其静态包含的内容
request:代表请求上下文，范围是一个请求涉及的几个页面，通常是一个页面和其包含的内容以及forward动作转向的页面
session:代表客户的一次会话上下文，范围是一个用户在会话有效期内多次请求所涉及的页面
application:全局作用域，代表Web应用程序上下文，范围是整个Web应用中所有请求所涉及的页面

## session与cookie的却别

1. Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。
2. cookie的存储限制了数据量，只允许4KB，而session是无限量的
3. 我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全
4. 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。

## Session实现原理

1. 当用户第一次访问时会创建一个session对象，这个session对象有一个唯一的ID SESSIONID。
2. 把SESSIONID作为cookie的值发送给浏览器保存
3. 第二次访问的时候，浏览器使用存有SESSIONID的cookie访问服务器
4. 服务器根据SESSIONID在服务器内存中搜索是否存放对应编号的session对象
5. 如果有找到了对应ID的session则返回该session，否则返回null或者创建新的session对象走流程1

## 如何防止SQL注入

使用采用预编译语句集

## 什么是 XSS 攻击，如何避免

XSS攻击涉及到三方：攻击者，用户，web server。用户是通过浏览器来访问web server上的网页，XSS攻击就是攻击者通过各种办法，在用户访问的网页中插入自己的脚本，让其在用户访问网页时在其浏览器中进行执行。攻击者通过插入的脚本的执行，来获得用户的信息，比如cookie，发送到攻击者自己的网站(跨站了)。所以称为跨站脚本攻击。XSS可以分为反射型XSS和持久性XSS，还有DOM Based XSS。(一句话，XSS就是在用户的浏览器中执行攻击者自己定制的脚本。)

XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码，白名单和黑名单结合。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。

使用 OWASP AntiSamy Project 和 OWASP ESAPI for Java 来防御 XSS(还有客户端的esapi4js: esapi.js)。AntiSamy 提供了 XSS Filter 的实现，而 ESAPI 则提供了对输出进行编码的实现。

## 什么是 CSRF 攻击，如何避免？

CSRF：Cross Site Request Forgery（跨站点请求伪造）。CSRF 攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。

防御：
- CSRF 漏洞进行检测的工具，如 CSRFTester、CSRF Request Builder...
- 验证 HTTP Referer 字段
- 添加并验证 token
- 添加自定义 http 请求头
- 敏感操作添加验证码
- 使用 post 请求

# 异常

## throw 和 throws 的区别

throw是抛出一个异常，throws是生命方法可能抛出的异常。

## try-catch-finally 中哪个部分可以省略？

catch和finally语句块可以省略其中之一

## 当try、catch中有return时，finally中的代码会执行么？

会，return的值是不会改变，但是实在finally执行之后return。

# 网络

## http的301和302有什么区别
301是永久重定向，而302是临时重定向

## forward和redirect的区别是什么？

1. 从地址栏来讲：forword是服务器内部的重定向，客户端浏览器的网址是不会发生变化的，但是那内容变化了。redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的地址。
2. 从数据共享来讲：forward的数据是可以共享的。redirect不能共享。
3. 从运用的地方来讲：forword 一般用于用户登录的时候，根据角色转发到相应的模块，redirect一般用于用户注销登录时返回主页面或者跳转到其他网站
4. 从效率上来说：forword效率高，而redirect效率低

## tcp与udp区别

- tcp是面向连接的，udp面向无连接
- 对于系统资源的要求，tcp多，udp少
- udp程序结构简单
- tcp保证数据正确性，udp可能丢包，tcp保证数据顺序，udp不保证

# 3 MySQL

## 3.1 sql中where的执行顺序

针对MySQL，其条件执行顺序是从左往右，自上而下。针对Oracle，其条件执行顺序是从右往左，自下而上。

MySQL的查询语句遵循原则：排除越多的条件放在第一个。

## 3.2 MySQL优化

用show status like 'Com_%'查看当前的数据库是以查询为主还是以插入为主

通过慢查询日志查看那些sql语句执行效率低，或者使用show processlist命令查看MySQL当前的线程状态和锁

使用EXPLAIN查看MySQL语句的执行过程并优化

## 3.3 乐观所（CAS compare and swap），悲观锁

每行数据后面都会有一个版本号，每次修改完数据写回时都要对比当前版本号与之前版本号，之前版本号加一大于当前版本号则数据顺利写回，小于等于则数据写回失败。

悲观锁每次读写都要锁定数据，操作完成之后才释放锁。

## 3.4 索引