介绍自己；

各位面试官好，我叫朱磊，毕业于广西大学信息管理与信息系统专业，2018年7月至2019年11月就职于中软国际，职能是作为SmartNDP WEB项目中链路模块的主要负责人，主要职责是保证链路模块整体功能的正常迭代，以及链路整个模块的框架的可维护性。技术方面熟悉java，mysql，spring，redis，kafka，git，maven。

自己的项目经验；



# 1 Spring

## 1.1 Spring bean的生命周期

首先是实例化bean，然后将bean的各种引用注入到bean中，如果实现了某些指定的接口，则会调用这些接口中要求实现的方法，之后就是使用bean，最后销毁bean。

## 1.2 SpringMVC，其处理流程

![image-20191116183355508](picture\image-20191116183355508.png)

1. 发起请求到前端控制器（DispatcherServlet）
2. 前端控制器请求HandlerMapping查找Handler（可以根据XML配置、注解进行查找）
3. 处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为 HandlerExecutionChain对象（包含一个Handler处理器（页面控制）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略
4. 前端控制器调用处理器适配器去执行Handler
5. 处理器适配器HandlerAdapter将会根据适配的结果去执行Handler
6. Handler执行完成给适配器返回ModelAndView
7.  处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）
8.  前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 
9.  视图解析器向前端控制器返回View 
10.  前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 
11.  前端控制器向用户响应结果 

首先用户发送请求到前端控制器，前端控制器根据请求信息去处理器映射器中找到相应的处理器，然后调用处理器适配器执行这个处理器，处理完成后获得一个ModelAndView，接着调用试图解析器和试图渲染器最终生成用户界面返回给用户。

## 1.3 SpringMVC怎么样设定重定向和转发

转发在返回值前面加forward，重定向在返回值前面加redirect。

## 1.4 springmvc怎么和ajax相互调用

通过jackson或者其他框架吧java里面的对象直接转化成json对象

## 1.5 sprinmvc中中文乱码

post乱码可以在web.xml中配置一个CharacterEncodingFilter过滤器。

get乱码：对参数进行重新编码，或者在tomcat配置文件中修改编码与项目的编码一致。

## 1.6 怎么样从springmvc中得到request或者session

直接在方法的形参中声明HttpServletRequest，springmvc就会自动把request对象传入。

## 1.7 怎么样把ModelMap里面的数据放入Session中

可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key

# 2 Java

## 2.1 HashMap

### 2.1.1 HashMap是有序的吗？

无序的，Java8中HashMap的存储结构是：数组+链表+红黑树

 ![img](picture\1216080-20180412104426360-1425516709.png) 

### 2.1.2 存在有序的HashMap吗？

TreeMap和LinkedHashMap。TreeMap默认是按照key值升序排序的，用红黑树作为实现的，可以使用比较器改变排序。LinkedHashMap是按照put的顺序排序的。

### 2.1.3 你有更好的实现有序Map的方法吗？

B+树

## 2.2 jvm加载类过程

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

## 2.3 HashCode的作用

hashcode是根据对象内容生成的一串编码，这串编码的作用就是辅助判断对象是否相等。

## 2.4 session和cookie的区别

cookie以文本格式存储在浏览器上，存储量有限；session存储在服务端，可以无限量存储多个变量并且比cookie更安全

## 2.5 JVM/GC

GC收集算法：标记-清除算法，复制算法，标记-整理算法，分代收集算法

## 2.6 Java基类Object类

所有类的父类，其中方法有equal，hashcode，toString ,clone，wait和notify，notifyAll。

## 2.7 引用

强引用：使用最普遍的引用，一般情况下，垃圾回收器绝对不会回收它。内存不足时，抛出OOM。软引用：内存空间足够，垃圾回收器不会回收它。反之，则回收。适用于缓存，而且不会OOM。弱引用：只有当垃圾回收器扫描到弱引用指向的对象时，才会回收它。生命周期比软引用更短。ThreadLocal的key使用了弱引用。虚引用：在任何时候都可能被垃圾回收器回收，必须与引用队列关联使用。

## final和static关键字的作用

final修饰类中的属性或变量，该属性或变量必须在构造函数执行完毕之前完成初始化。final修饰的变量的值不可以改变。final修饰的方法可以被继承不可以被重写。final修饰的类不可以被继承。

static修饰的方法可以不通过本类的对象即可调用，static修饰的变量为全局变量，所有的类共享该变量。只有内部类才可以用static修饰。

## java 中操作字符串都有哪些类？它们之间有什么区别？

- String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。
- StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。
- StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。

## 2.8 线程与进程之间的不同

进程是资源分配的最小单位，线程是程序执行的最小单位，每个进程有自己的独立地址空间，线程共享进程中的数据。

## 2.9 Thread类中的start和run方法有什么区别

start被用来启动新线程并且在内部调用了run，run不能。start不能被重复调用，run可以。

## 2.10 在多线程中，什么是上下文切换

存储和恢复CPU状态的过程，它使得线程能够从中断点恢复。

## 2.11 volatile变量

一种实现数据共享的轻量锁，被volatile修饰的变量不会被重排序，并且修改和获取的时候都是在主内存中进行的，不是在线程私有的内存中进行的。

## 2.12 死锁是什么？如何避免死锁？

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

死锁发生的四个条件：

- 互斥条件：一个资源每次只能被一个线程使用
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系

避免死锁最简单的方法及时阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁。

## 2.13 Thread类中的yield方法有什么作用

Thread.yield()方法会使当前线程从运行状态变为就绪状态，把运行机会让给其他相同优先级的线程。

## 2.14 Java中interrupted 和 isInterruptedd方法的区别

interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态。isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态。

```Java
public class ThreadTest {
    public static void main(String[] args) {
        // 调用interrupt将线程中断状态设置为true
        Thread.currentThread().interrupt();
        System.out.println(Thread.currentThread().isInterrupted());
        System.out.println(Thread.interrupted());
        // 线程中断状态被interrupted重置为false
        System.out.println(Thread.currentThread().isInterrupted());
    }
}

true
true
false
```

## 2.15 Java多线程中调用wait() 和 sleep()方法有什么不同

sleep()和wait()都是使线程暂停执行一段时间的方法。区别：

1. 原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。而wait()方法是Object类的方法，用于线程间的通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程用调用notify()或notifyAll()时才苏醒过来，开发人员也可以给它指定一个时间使其自动醒来
2. 对锁的处理机制不同：由于sleep()方法的主要作用是让线程暂停一段时间，时间一到则自动恢复，不涉及线程间的通信，因此调用sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。
3. 使用区域不同：wait()方法必须放在同步控制方法或者同步语句块中使用，而sleep方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。

由于sleep不会释放锁标志，容易导致死锁问题的发生，一般情况下，不推荐使用sleep()方法，而推荐使用wait()方法。

## 2.16 守护线程

在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 
 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程

## 2.17 java thread状态

- new：初始状态，线程刚创建，尚未启动
- runnable：运行状态，Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）
- blocked：阻塞状态，线程阻塞于锁
- waiting：等待状态，进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）
- timed_waiting：超时等待，该状态不同于WAITING，它可以在指定的时间后自行返回
- terminated：终止，表示该线程已经执行完毕

## 2.18 进程调度算法

**实时系统**：FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。  
 **交互式系统**：RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。

## 2.19 synchronized与lock和volatile区别

## 2.20 四种常见线程池以及ThreadPoolExecutor

ThreadPoolExecutor四种线程池就是通过此类的构造方法实现的。设置核心线程数量，线程存活时间，线程池可以容纳的最大线程数。线程池中的任务队列三种：SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。

## 2.21 Executor拒绝策略

1. AbortPolicy:为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try 
    catch，否则程序会直接退出.
2. DiscardPolicy:直接抛弃，任务不执行，空方法
3. DiscardOldestPolicy:从队列里面抛弃head的一个任务，并再次execute 此task。
4. CallerRunsPolicy:在调用execute的线程里面执行此command，会阻塞入
5. 用户自定义拒绝策略:实现RejectedExecutionHandler，并自己定义策略模式 

## 2.22 CopyOnWriteArrayList

CopyOnWriteArrayList :  写时加锁，当添加一个元素的时候，将原来的容器进行copy，复制出一个新的容器，然后在新的容器里面写，写完之后再将原容器的引用指向新的容器，而读的时候是读旧容器的数据，所以可以进行并发的读，但这是一种弱一致性的策略。  
 使用场景：CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。

## 2.23 java里的阻塞队列

ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。   LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 
 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。   DelayQueue：一个使用优先级队列实现的无界阻塞队列。   SynchronousQueue：一个不存储元素的阻塞队列。   LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。   LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

## 2.24 Fork/Join框架

## 2.25 原子操作类

## 2.26 栅栏，闭锁，信号量

## 2.27 进程间通信方式

1. 管道
2. 有名管道
3. 信号量
4. 消息队列
5. 信号
6. 共享内存
7. 套接字

## 2.28 并发和并行的区别

并发：同一时间段，多个任务都在执行，单位时间内不一定同时执行;并行：单位时间内，多个任务同时执行。



# 3 MySQL

## 3.1 sql中where的执行顺序

针对MySQL，其条件执行顺序是从左往右，自上而下。针对Oracle，其条件执行顺序是从右往左，自下而上。

MySQL的查询语句遵循原则：排除越多的条件放在第一个。

## 3.2 MySQL优化

用show status like 'Com_%'查看当前的数据库是以查询为主还是以插入为主

通过慢查询日志查看那些sql语句执行效率低，或者使用show processlist命令查看MySQL当前的线程状态和锁

使用EXPLAIN查看MySQL语句的执行过程并优化

## 3.3 乐观所（CAS compare and swap），悲观锁

每行数据后面都会有一个版本号，每次修改完数据写回时都要对比当前版本号与之前版本号，之前版本号加一大于当前版本号则数据顺利写回，小于等于则数据写回失败。

悲观锁每次读写都要锁定数据，操作完成之后才释放锁。

## 3.4 索引