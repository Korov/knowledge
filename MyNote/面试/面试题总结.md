介绍自己；

各位面试官好，我叫朱磊，毕业于广西大学信息管理与信息系统专业，2018年7月至2019年11月就职于中软国际，职能是作为SmartNDP WEB项目中链路模块的主要负责人，主要职责是保证链路模块整体功能的正常迭代，以及链路整个模块的框架的可维护性。技术方面熟悉java，mysql，spring，redis，kafka，git，maven。

自己的项目经验；



# 1 Spring

## 1.1 Spring bean的生命周期

首先是实例化bean，然后将bean的各种引用注入到bean中，如果实现了某些指定的接口，则会调用这些接口中要求实现的方法，之后就是使用bean，最后销毁bean。

## 1.2 SpringMVC，其处理流程

![image-20191116183355508](picture\image-20191116183355508.png)

1. 发起请求到前端控制器（DispatcherServlet）
2. 前端控制器请求HandlerMapping查找Handler（可以根据XML配置、注解进行查找）
3. 处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为 HandlerExecutionChain对象（包含一个Handler处理器（页面控制）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略
4. 前端控制器调用处理器适配器去执行Handler
5. 处理器适配器HandlerAdapter将会根据适配的结果去执行Handler
6. Handler执行完成给适配器返回ModelAndView
7.  处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）
8.  前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 
9.  视图解析器向前端控制器返回View 
10.  前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 
11.  前端控制器向用户响应结果 

首先用户发送请求到前端控制器，前端控制器根据请求信息去处理器映射器中找到相应的处理器，然后调用处理器适配器执行这个处理器，处理完成后获得一个ModelAndView，接着调用试图解析器和试图渲染器最终生成用户界面返回给用户。

## 1.3 SpringMVC怎么样设定重定向和转发

转发在返回值前面加forward，重定向在返回值前面加redirect。

## 1.4 springmvc怎么和ajax相互调用

通过jackson或者其他框架吧java里面的对象直接转化成json对象

## 1.5 sprinmvc中中文乱码

post乱码可以在web.xml中配置一个CharacterEncodingFilter过滤器。

get乱码：对参数进行重新编码，或者在tomcat配置文件中修改编码与项目的编码一致。

## 1.6 怎么样从springmvc中得到request或者session

直接在方法的形参中声明HttpServletRequest，springmvc就会自动把request对象传入。

## 1.7 怎么样把ModelMap里面的数据放入Session中

可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key

# 2 Java

## 2.1 HashMap

### 2.1.1 HashMap是有序的吗？

无序的，Java8中HashMap的存储结构是：数组+链表+红黑树

 ![img](picture\1216080-20180412104426360-1425516709.png) 

### 2.1.2 存在有序的HashMap吗？

TreeMap和LinkedHashMap。TreeMap默认是按照key值升序排序的，用红黑树作为实现的，可以使用比较器改变排序。LinkedHashMap是按照put的顺序排序的。

### 2.1.3 你有更好的实现有序Map的方法吗？

B+树

## 2.2 jvm加载类过程

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

## 2.3 HashCode的作用

hashcode是根据对象内容生成的一串编码，这串编码的作用就是辅助判断对象是否相等。

## 2.4 session和cookie的区别

cookie以文本格式存储在浏览器上，存储量有限；session存储在服务端，可以无限量存储多个变量并且比cookie更安全

## 2.5 JVM/GC，高并发

GC收集算法：标记-清除算法，复制算法，标记-整理算法，分代收集算法

## 2.6 Java基类Object类

## 2.7 引用

强引用：使用最普遍的引用，一般情况下，垃圾回收器绝对不会回收它。内存不足时，抛出OOM。软引用：内存空间足够，垃圾回收器不会回收它。反之，则回收。适用于缓存，而且不会OOM。弱引用：只有当垃圾回收器扫描到弱引用指向的对象时，才会回收它。生命周期比软引用更短。ThreadLocal的key使用了弱引用。虚引用：在任何时候都可能被垃圾回收器回收，必须与引用队列关联使用。

## 2.8 线程与进程之间的不同

进程是资源分配的最小单位，线程是程序执行的最小单位，每个进程有自己的独立地址空间，线程共享进程中的数据。

## 2.9 Thread类中的start和run方法有什么区别

start被用来启动新线程并且在内部调用了run，run不能。start不能被重复调用，run可以。

## 2.10 在多线程中，什么是上下文切换

存储和回复CPU状态的过程，它使得线程能够从中断点恢复。

## 2.11 volatile变量

一种实现数据共享的轻量锁，被volatile修饰的变量不会被重排序，并且修改和获取的时候都是在主内存中进行的，不是在线程私有的内存中进行的。

## 2.12 死锁是什么？如何避免死锁？

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

死锁发生的四个条件：

- 互斥条件：一个资源每次只能被一个线程使用
- 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系

避免死锁最简单的方法及时阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作来避免死锁。

## 2.13 Thread类中的yield方法有什么作用

Thread.yield()方法会使当前线程从运行状态变为就绪状态，把运行机会让给其他相同优先级的线程。

# 3 MySQL

## 3.1 sql中where的执行顺序

针对MySQL，其条件执行顺序是从左往右，自上而下。针对Oracle，其条件执行顺序是从右往左，自下而上。

MySQL的查询语句遵循原则：排除越多的条件放在第一个。

## 3.2 MySQL优化

用show status like 'Com_%'查看当前的数据库是以查询为主还是以插入为主

通过慢查询日志查看那些sql语句执行效率低，或者使用show processlist命令查看MySQL当前的线程状态和锁

使用EXPLAIN查看MySQL语句的执行过程并优化

## 3.3 乐观所，悲观锁

## 3.4 索引