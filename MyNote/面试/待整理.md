# 数据结构和算法

1. B+树
2. 快速排序，堆排序，插入排序（其实八大排序算法都应该了解
3. 一致性Hash算法，一致性Hash算法的应用

# JVM

14. dump文件的分析。

# 多线程

7. 可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）。
8. 悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决。
9. ABC三个线程如何保证顺序执行。
10. 线程的状态都有哪些。
11. sleep和wait的区别。
12. notify和notifyall的区别。
13. ThreadLocal的了解，实现原理。

# 数据库相关

常见的数据库优化手段 索引的优缺点，什么字段上建立索引 数据库连接池。 durid的常用配置。

# 计算机网络

TCP，UDP区别。 三次握手，四次挥手，为什么要四次挥手。 长连接和短连接。 连接池适合长连接还是短连接。

# 设计模式

观察者模式 代理模式 单例模式，有五种写法，可以参考文章单例模式的五种实现方式 可以考Spring中使用了哪些设计模式

# 分布式相关

分布式事务的控制。 分布式锁如何设计。 分布式session如何设计。 dubbo的组件有哪些，各有什么作用。 zookeeper的负载均衡算法有哪些。 dubbo是如何利用接口就可以通信的。

# 缓存相关

redis和memcached的区别。 redis支持哪些数据结构。 redis是单线程的么，所有的工作都是单线程么。 redis如何存储一个String的。 redis的部署方式，主从，集群。 redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。 redis持久化策略。

# 框架相关

SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。 Mybatis如何找到指定的Mapper的，如何完成查询的。 Quartz是如何完成定时任务的。 自定义注解的实现。 Spring使用了哪些设计模式。 Spring的IOC有什么优势。 Spring如何维护它拥有的bean。 一些较新的东西 JDK8的新特性，流的概念及优势，为什么有这种优势。 区块链了解 如何设计双11交易总额面板，要做到高并发高可用



# **多线程、并发及线程的基础问题**

**1）Java 中能创建 volatile 数组吗？**

能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

**2）volatile 能使得一个非原子操作变成原子操作吗？**

一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。

**3）volatile 修饰符的有过什么实践？**

一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

**4）volatile 类型变量提供什么保证？**

volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。

**5) 10 个线程和 2 个线程的同步代码，哪个更容易写？**

从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。

**6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？**

wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：

// The standard idiom for using the wait method

synchronized(obj) {

while(condition does not hold)

obj.wait(); // (Releases lock, and reacquires on wakeup)

... // Perform action appropriate to condition

}

**7）什么是多线程环境下的伪共享（false sharing）？**

伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：

![img](https:////upload-images.jianshu.io/upload_images/13317307-75f20eee19d31ec9?imageMogr2/auto-orient/strip|imageView2/2/w/520/format/webp)

# **有经验程序员的 Java 面试题**

伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。

**8）什么是 Busy spin？我们为什么要使用它？**

Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。

**9）Java 中怎么获取一份线程 dump 文件？**

在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。

**10）Swing 是线程安全的？**

不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。

**11）什么是线程局部变量？**

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

**12）用 wait-notify 写一段代码来解决生产者-消费者问题？**

请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。

**13) 用 Java 写一个线程安全的单例模式（Singleton）？**

请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。

**14）Java 中 sleep 方法和 wait 方法的区别？**

虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

**15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？**

不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。

**16）我们能创建一个包含可变对象的不可变对象吗？**

是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。

# **数据类型和 Java 基础面试问题**

**17）Java 中应该使用什么数据类型来代表价格？**

如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。

**18）怎么将 byte 转换为 String？**

可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。

**19）Java 中怎样将 bytes 转换为 long 类型？**

这个问题你来回答 :-)

**20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？**

是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。

**21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；**

**22）哪个类包含 clone 方法？是 Cloneable 还是 Object？**

java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。

**23）Java 中 ++ 操作符是线程安全的吗？**

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

**24）a = a + b 与 a += b 的区别**

+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下：

byte a = 127;

byte b = 127;

b = a + b; // error : cannot convert from int to byte

b += a; // ok

（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）

**25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？**

不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。

**26）3\*0.1 == 0.3 将会返回什么？true 还是 false？**

false，因为有些浮点数不能完全精确的表示出来。

**27）int 和 Integer 哪个会占用更多的内存？**

Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。

**28）为什么 Java 中的 String 是不可变的（Immutable）？**

Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。

**29）我们能在 Switch 中使用 String 吗？**

从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。

**30）Java 中的构造器链是什么？**

当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。

# **JVM 底层 与 GC（Garbage Collection） 的面试问题**

**31）64 位 JVM 中，int 的长度是多数？**

Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。

**32）Serial 与 Parallel GC之间的不同之处？**

Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。

**33）32 位和 64 位的 JVM，int 类型变量的长度是多数？**

32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。

**34）Java 中 WeakReference 与 SoftReference的区别？**

虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。

**35）WeakHashMap 是怎么工作的？**

WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。

**36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？**

当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。

**37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？**

你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。

**38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？**

理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。

**39）JRE、JDK、JVM 及 JIT 之间有什么不同？**

JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。

![img](https:////upload-images.jianshu.io/upload_images/13317307-07cf0726e099a2b1?imageMogr2/auto-orient/strip|imageView2/2/w/320/format/webp)

# **3 年工作经验的 Java 面试题**

**40）解释 Java 堆空间及 GC？**

当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。

![img](https:////upload-images.jianshu.io/upload_images/13317307-9b28f7e78832e184?imageMogr2/auto-orient/strip|imageView2/2/w/400/format/webp)

# **JVM 底层面试题及答案**

**41）你能保证 GC 执行吗？**

不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。

**42）怎么获取 Java 程序使用的内存？堆使用的百分比？**

可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。

**43）Java 中堆和栈有什么区别？**

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

![img](https:////upload-images.jianshu.io/upload_images/13317307-97b37570929fe0ab?imageMogr2/auto-orient/strip|imageView2/2/w/400/format/webp)

# **关于内存的的面试问题和答案**

**Java 基本概念面试题**

**44）“a==b”和”a.equals(b)”有什么区别？**

如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。

**45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？**

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。

**46）final、finalize 和 finally 的不同之处？**

final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。

**47）Java 中的编译期常量是什么？使用它又什么风险？**

公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。

# **Java 集合框架的面试题**

这部分也包含数据结构、算法及数组的面试问题

**48) List、Set、Map 和 Queue 之间的区别**

List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。

**49）poll() 方法和 remove() 方法的区别？**

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

**50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？**

PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。

**51）ArrayList 与 LinkedList 的不区别？**

最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。

**52）用哪两种方式来实现集合的排序？**

你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。

**53）Java 中怎么打印数组？**

你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。

**54）Java 中的 LinkedList 是单向链表还是双向链表？**

是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。

**55）Java 中的 TreeMap 是采用什么树实现的？**

Java 中的 TreeMap 是使用红黑树实现的。

**56) Hashtable 与 HashMap 有什么不同之处？**

这两个类有许多不同的地方，下面列出了一部分：

a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。

b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。

c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。

更多的不同之处参见答案。

**57）Java 中的 HashSet，内部是如何工作的？**

HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。

**58）写一段代码在遍历 ArrayList 时移除一个元素？**

该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。

**59）我们能自己写一个容器类，然后使用 for-each 循环码？**

可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。

**60）ArrayList 和 HashMap 的默认大小是多数？**

在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：

// from ArrayList.java JDK 1.7

privatestaticfinalintDEFAULT_CAPACITY = 10;

//from HashMap.java JDK 7

staticfinalintDEFAULT_INITIAL_CAPACITY = 1<< 4; // aka 16

**61）有没有可能两个不相等的对象有有相同的 hashcode？**

有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

**62）两个相同的对象会有不同的的 hash code 吗？**

不能，根据 hash code 的规定，这是不可能的。

**63）我们可以在 hashcode() 中使用随机数字吗？**

不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。

**64）Java 中，Comparator 与 Comparable 有什么不同？**

Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。

**65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？**

因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。

# **Java IO 和 NIO 的面试题**

IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。

**66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？**

**67）Java 中怎么创建 ByteBuffer？**

**68）Java 中，怎么读写 ByteBuffer ？**

**69）Java 采用的是大端还是小端？**

**70）ByteBuffer 中的字节序是什么？**

**71）Java 中，直接缓冲区与非直接缓冲器有什么区别？**

**72）Java 中的内存映射缓存区是什么？**

**73）socket 选项 TCP NO DELAY 是指什么？**

**74）TCP 协议与 UDP 协议有什么区别？**

**75）Java 中，ByteBuffer 与 StringBuffer有什么区别？**

# **Java 最佳实践的面试问题**

包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。

**76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？**

这是我在写Java 并发程序的时候遵循的一些最佳实践：

a）给线程命名，这样可以帮助调试。

b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。

c）如果可以，更偏向于使用 volatile 而不是 synchronized。

d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。

e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。

**77）说出几点 Java 中使用 Collections 的最佳实践**

这是我在使用 Java 中 Collectionc 类的一些最佳实践：

a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。

b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。

c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。

d）使用迭代器来循环集合。

e）使用集合的时候使用泛型。

**78）说出至少 5 点在 Java 中使用线程的最佳实践。**

这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：

a）对线程命名

b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。

c）使用线程池

**79）说出 5 条 IO 的最佳实践**

IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：

a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。

b）使用 NIO 和 NIO2

c）在 finally 块中关闭流，或者使用 try-with-resource 语句。

d）使用内存映射文件获取更快的 IO。

**80）列出 5 个应该遵循的 JDBC 最佳实践**

有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：

a）使用批量的操作来插入和更新数据

b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。

c）使用数据库连接池

d）通过列名来获取结果集，不要使用列的下标来获取。

**81）说出几条 Java 中方法重载的最佳实践？**

下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。

a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。

b）不要重载参数数量一致，而只是参数顺序不同的方法。

c）如果重载的方法参数个数多于 5 个，采用可变参数。

Date、Time 及 Calendar 的面试题

**82）在多线程环境下，SimpleDateFormat 是线程安全的吗？**

不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

**83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？**

Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。

**84）Java 中，怎么在格式化的日期中显示时区？**

**85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？**

**86）Java 中，如何计算两个日期之间的差距？**

**87）Java 中，如何将字符串 YYYYMMDD 转换为日期？**

# **单元测试 JUnit 面试题**

**89）如何测试静态方法？**

可以使用 PowerMock 库来测试静态方法。

**90）怎么利用 JUnit 来测试一个方法的异常？**

**91）你使用过哪个单元测试库来测试你的 Java 程序？**

**92）@Before 和 @BeforeClass 有什么区别？**

# **编程和代码相关的面试题**

93）怎么检查一个字符串只包含数字？

94）Java 中如何利用泛型写一个 LRU 缓存？

95）写一段 Java 程序将 byte 转换为 long？

95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？

97）Java 中，怎么获取一个文件中单词出现的最高频率？

98）如何检查出两个给定的字符串是反序的？

99）Java 中，怎么打印出一个字符串的所有排列？

100）Java 中，怎样才能打印出数组中的重复元素？

101）Java 中如何将字符串转换为整数？

102）在没有使用临时变量的情况如何交换两个整数变量的值？

# **关于 OOP 和设计模式的面试题**

这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。

**103）接口是什么？为什么要使用接口而不是直接使用具体类？**

接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。

**104）Java 中，抽象类与接口之间有什么不同？**

Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。

**105）除了单例模式，你在生产环境中还用过什么设计模式？**

这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。

**106）你能解释一下里氏替换原则吗?**

**107) 什么情况下会违反迪米特法则？为什么会有这个问题？**

迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。

**108）适配器模式是什么？什么时候使用？**

适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。

**109）什么是“依赖注入”和“控制反转”？为什么有人使用？**

**110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？**

**111）构造器注入和 setter 依赖注入，那种方式更好？**

每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。

**112）依赖注入和工程模式之间有什么不同？**

虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。

**113）适配器模式和装饰器模式有什么区别？**

虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

**114）适配器模式和代理模式之前有什么不同？**

这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

**115）什么是模板方法模式？**

模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。

**116）什么时候使用访问者模式？**

访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。

**117）什么时候使用组合模式？**

组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。

**118）继承和组合之间有什么不同？**

虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。

**119）描述 Java 中的重载和重写？**

重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。

**120）Java 中，嵌套公共静态类与顶级类有什么不同？**

类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。

**121) OOP 中的 组合、聚合和关联有什么区别？**

如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。

**122）给我一个符合开闭原则的设计模式的例子？**

开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。

**123）抽象工厂模式和原型模式之间的区别？**

**124）什么时候使用享元模式？**

享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。

### 1、什么是 SpringMvc？

答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整

### 2、Spring MVC 的优点：

答：

1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 组件.并且和 Spring 提供的其他基础结构紧密集成.

2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)3）可以任意使用各种视图技术,而不仅仅局限于 JSP4）支持各种请求资源的映射策略5）它应是易于扩展的

### 3、SpringMVC 工作原理？

答：

1）客户端发送请求到 DispatcherServlet

2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller

3）Controller 调用业务逻辑后，返回 ModelAndView

4）DispatcherServlet 查询 ModelAndView，找到指定视图

5）视图将结果返回到客户端

### 4、SpringMVC 流程？

答：

1）用户发送请求至前端控制器 DispatcherServlet。

2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。

3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。

4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。

5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)

6）Controller 执行完成返回 ModelAndView。

7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。

9）ViewReslover 解析后返回具体 View。

10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。

11）DispatcherServlet 响应用户。

### 6、SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？

答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解方案是在控制器里面不能写字段。

### 8、SpingMvc 中的控制器的注解一般****用那个****,有没有别的注解可以替代

答：一般用@Conntroller 注解,表示是表现层,不能用用别的注解代替

### 9、 @RequestMapping 注解用在类上面有什么作用？

答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类有响应请求的方法都是以该地址作为父路径。

### 10、怎么样把某个请求映射到特定的方法上面？

答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路

### 11、如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？

答：可以在@RequestMapping 注解里面加上 method=RequestMethod.GET

### 12、怎么样在方法里面得到 Request,或者 Session？

答：直接在方法的形参中声明 request,SpringMvc 就自动把 request 对象传

### 13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？

答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样

### 14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这象？

答：直接在方法中声明这个对象,SpringMvc 就自动会把属性赋值到这个对象里面。

### 15、SpringMvc 中函数的返回值是什么？

答：返回值可以有很多类型,有 String, ModelAndView,当一般用 String 比较好

### 16、SpringMVC 怎么样设定重定向和转发的？

答：在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:百度一下，你就知道"

### 17、SpringMvc 用什么对象从后台向前台传递数据的？

答：通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以过 el 表达式拿到。

### 18、SpringMvc 中有个类把视图和数据都合并的一起的,叫什么？

答：叫 ModelAndView。

### 19、怎么样把 ModelMap 里面的数据放入 Session 里面？

答：可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 的 key

### 20、SpringMvc 怎么和 AJAX 相互调用的？

答：通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象具体步骤如下 ：

1）加入 Jackson.jar

2）在配置文件中配置 json 的映射

3）在接受 Ajax 方法里面可以直接返回 Object,List 等,但方法前面要加上@ResponseB注解

### 21、当一个方法向 AJAX 返回特殊对象,譬如 Object,List 等,需要做什么处理？

答：要加上@ResponseBody 注解

### 22、SpringMvc 里面拦截器是怎么写的？

答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在 SpringMvc 的配置文配置拦截器即可：mvc:interceptors

<mvc:mapping path="/modelMap.do" />

</mvc:interceptor></mvc:interceptors>

#### JAVA

5个常用的java-api包。
 String类中常用的5个方法。
 API接口开发的注意事项。
 TCP/IP、HTTP协议。

#### 集合相关的问题(重点)

HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap、ArrayList、LinkedList的实现和区别之类的。
 上述集合中的那些是线程安全的，那些不是。
 在那些场景使用这些集合。
 List、Map、Set三个接口，存取元素时，各有什么特点。

#### 线程相关问题（重点）

创建线程的几种方式。
 线程同步的方法。
 wait和sleep区别。
 Runnable接口和Callable接口的区别。
 如何实现线程安全。

#### 框架相关知识（这块反而不多）

Mybatis#和$的区别.
 Hibernate和Mybatis的区别。
 Spring MVC和Struts2的区别.
 Hibernate的缓存机制。
 什么是Hibernate延迟加载.
 为什么要用spring。

#### SQL(主要考察Group by和Order by相关知识)

查询每个班级成绩最高的学生。
 查找出每个班级成绩第二的学生。
 按照班级查询每个班上总分前三的学生。
 查找入职员工时间排名倒数第三的员工所有信息。
 薪水排序后薪水排名在第2--8的员工。
 按工资进行排名，排名从1开始，工资相同排名相同（如果两人并列第一则没有第二名，从第三名继续排）。
 用一条sql语句取出所有姓名有重复的学员姓名和重复的记录数。

#### JavaScript/JSP/Servet （这些一般是基础题）

JSP的内置对象以及作用。
 JSTL的常用标签。
 Servlet的生命周期。
 URL和URI的区别。
 Ajax同步和异步的区别。
 使用ajax发送异步请求的流程。

#### 其它

&和&&的区别。
 ==和equals的区别。
 int和Integer的自动拆箱/装箱相关问题。
 IO和NIO的区别。
 final、finally、finalize的区别。
 重载（Overload）和重写（Override）的区别。
 String、StringBuffer和StringBuilder的区别。
 如何实现浅克隆和深克隆。
 单例模式的实现以及最优。
 排序的实现（冒泡、选择、快速等）。
 去除重复的元素(实际是重写equals和hashcode)。

## 阿里面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-c8f86ed3d4e79f75.png?imageMogr2/auto-orient/strip|imageView2/2/w/563/format/webp)

- 多个线程同时读写，读线程的数量远远大于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？
- JAVA的AQS是否了解，它是干嘛的？
- 除了synchronized关键字之外，你是怎么来保障线程安全的？
- Tomcat本身的参数你一般会怎么调整？
- 你有没有用过Spring的AOP? 是用来干嘛的? 大概会怎么使用？
- 如果一个接口有2个不同的实现, 那么怎么来Autowire一个指定的实现？
- 如果想在某个Bean生成并装配完毕后执行自己的逻辑，可以什么方式实现？
- SpringBoot没有放到web容器里为什么能跑HTTP服务？
- SpringBoot中如果你想使用自定义的配置文件而不仅仅是application.properties，应该怎么弄？
- SpringMVC如果希望把输出的Object(例如XXResult或者XXResponse)这种包装为JSON输出, 应该怎么处理?
- 如果有很多数据插入MYSQL 你会选择什么方式?
- 如果查询很慢，你会想到的第一个方式是什么？索引是干嘛的?
- 查询死掉了，想要找出执行的查询进程用什么命令？找出来之后一般你会干嘛？
- 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有什么关系？
- 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正确的？
- 你知道哪些或者你们线上使用什么GC策略? 它有什么优势，适用于什么场景？
- JAVA类加载器包括几种？它们之间的父子关系是怎么样的？双亲委派机制是什么意思？有什么好处？
- 如何自定义一个类加载器？你使用过哪些或者你在什么场景下需要一个自定义的类加载器吗？
- 堆内存设置的参数是什么？
- HashMap和Hashtable的区别。
- 实现一个保证迭代顺序的HashMap。
- 说一说排序算法，稳定性，复杂度。
- 说一说GC。
- JVM如何加载一个类的过程，双亲委派模型中有哪些方法？
- TCP如何保证可靠传输？三次握手过程？

## 京东面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-c9edc37198239259.png?imageMogr2/auto-orient/strip|imageView2/2/w/502/format/webp)

- java常用的数据结构有哪些?哪些是线程安全的?是怎么保证线程安全的？
- Redis中的Lua有没有使用过? 可以用来做什么? 为什么可以这么用?
- 线程池内部工作原理可以说一下么？
- 死锁是什么意思，形成条件是什么？出现死锁是可以通过什么方式去排查。
- 在交易过程中如何放在用户在支付时的重复支付（交叉支付），请写出你了解的方案或使用的过的方案。
- 数据库索引有哪几种，他们之间的区别。
- 程序开发时通过开发工具DeBug调试时，控制台显示的内容都包含什么？哪些内容可以帮助你发现问题和解决问题。
- RPC通信过程中，假设A系统提供了一个方法入参是一个JavaBean，出参也是一个JavaBean。另外两个系统B系统、C系统调用接口，调用方B想让提供方A增加一个返回参数，假设服务提供方A增加了返回参数，请问C系统调用方需要做什么处理？
- 了解哪些设计模式，用伪代码实现一个你熟悉的设计模式。
- 讲一下怎么使用分布式锁。
- 说说HashMap的原理, 以及HashMap如何扩充bucket的大小。
- Redis的Pipeline是用来干什么的?
- Mysql索引的分类(Btree, hash)，各自使用什么情况 。
- 说说Myisam, Innodb区别。
- 知道哪些负载均衡算法。
- 说一下Btree的查找原理。
- 简述三次握手，如果c端发起握手请求，s端无法立刻建立连接应该回应什么？

说到这里，也给大家推荐一个架构交流学习群：614478470 **[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。合理利用自己每一分每一秒的时间来学习提升自己，不要再用"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！

## 去哪儿网面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-bc81f98acec104b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

- 自我介绍，项目介绍。
- mysql数据库调优。
- sql优化。
- like能用索引吗？
- java对象四种引用。
- GC原理。
- jvm内存结构。
- 说一下你学过jvm 在书写代码上对你有什么帮助和提高。
- 千万数据量的查询你会怎么做？
- HashMap在jdk1.7和1.8的区别，为什么引入这个概念？hash碰撞怎么解决，为什么1.8要比1.7更好，好在哪？
- 关于你的项目，如果并发很大，你会怎么改造。
- 方法区里什么样的对象有可能被回收。
- 线上cpu飙升100%你怎么处理。
- 频繁FullGC怎么处理。
- 线程池创建有几种，为什么创建定长的线程池个数最好是5，10，15这样的数字。
- linux命令。
- 伊甸区和幸存区可动态变化吗？
- redis和memcached区别。
- 说几个jdk命令，jmap是什么意思。
- 如果并发很大，你对数据的正确性怎么保证。

## 饿了么面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-3fb6fd1bb46491ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

- http和https的区别，https原理，http2.0与1.0的区别。
- Java的垃圾回收机制，Java文件加载机制，tomcat类加载机制，锁机制，jvm原理及线上调优，jvm内存模型。
- 多线程，有哪些可以保持进程同步的方法，创建线程的几种方法，对i++多线程访问你会怎么做。
- Java的设计模式，单例有什么模式，懒汉为什么加volotile，volotile的内存屏障，如何避免死锁。
- 考虑单例模式的编写，要线程安全且内存消耗小（剑指offer原题）。
- String、StringBuilder、StringBuffer区别；String类能被继承吗？为什么？
- 在白纸上手写二分法排序算法（lintcode上原题）；二分查找的思想。
- 查找单链表中倒数第k个节点的算法，手写（lintcode上原题）；最常见的排序算法你见过哪些，快排的基本思想及时间复杂度。
- 常见的数据结构有哪些。
- hashmap、hashcode一样，不equals怎么处理 ；hashcode实现原理，currentHashMap原理，实现细节，怎么实现同步的；类为什么要有hascode方法，是不是主要在集合类中都要实现hashcode方法；equals方法怎么实现；两个不同的对象可能有相同的hashcode值吗；常用集合有哪些。
- tcp三次握手，四次挥手协议。
- 架构设计一个开发性问题，设计一个Nginx管理的中间件，怎么设计。
- 所有的类都继承与object，你用过object类的直接子类有哪些，object类常用的方法有哪些。
- Java会出现内存泄漏吗，如果回，在哪种情况下？
- 抽象类和接口的区别。
- 平时怎么扩展自己的专业知识水平。

## 百度面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-9fde129a839640a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

- 什么是 Java 的反射机制。
- Cookie 和 Session的区别。
- get 和 post请求的区别。
- IOC的优点是什么。
- IO 和 NIO的区别，NIO优点。
- JRE、JDK、JVM 及 JIT 之间有什么不同。
- Hashcode 的作用。
- 简述一致性 Hash 算法。
- 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里。
- 为什么 Map 接口不继承 Collection 接口。
- 说出几点 Java 中使用 Collections 的最佳实践？
- GC是什么？为什么要有GC。
- 什么时候会导致垃圾回收。
- GC 有几种方式？怎么配置。
- 什么时候一个对象会被GC？ 如何判断一个对象是否存活。
- 垃圾回收器的基本原理是什么？
- Serial 与 Parallel GC之间的不同之处。
- JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代。
- 吞吐量优先和响应优先的垃圾收集器选择。
- 说说你知道的几种主要的jvm 参数。
- Java中存在内存泄漏问题吗？请举例说明。
- 什么是线程，多线程的优点是什么？以及简单说一下多线程的几种实现方式。
- ThreadLocal 用途是什么，原理是什么，用的时候要注意什么?
- 线程池是什么？为什么要使用它？如何创建一个Java线程池？
- ThreadPool用法与优势可以说一下么？
- synchronized 的原理是什么？synchronized 和 ReentrantLock 有什么不同？
- 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行同步块内的线程抛出异常会发生什么？
- 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题。
- Java中活锁和死锁有什么区别？
- Executors类是什么？ Executor和Executors的区别？
- 什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合？
- 你能写出三种单例模式实现么？
- 你知道Google是如何在一秒内把搜索结果返回给用户？
- 高并发下，如何做到安全的修改同一行数据？
- 如何避免浏览器缓存。
- 大型网站在架构上应当考虑哪些问题？
- 最近有在看什么书么，印象最深刻的是什么？
- 你们线上应用的 JVM 参数有哪些？
- 能简单说下你对算法的理解么？

# 我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？

为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：**自动配置。**



设计模式作为工作学习中的枕边书，却时常处于勤说不用的尴尬境地，也不是我们时常忘记，只是一直没有记忆。

今天，在IT学习者网站就设计模式的内在价值做一番探讨，并以spring为例进行讲解，只有领略了其设计的思想理念，才能在工作学习中运用到“无形”。

Spring作为业界的经典框架，无论是在架构设计方面，还是在代码编写方面，都堪称行内典范。好了，话不多说，开始今天的内容。

spring中常用的设计模式达到九种，我们一一举例：

### 第一种：简单工厂

又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。

简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
 spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。



```xml
<beans>
    <bean id="singletonBean" class="com.itxxz.HelloItxxz">
        <constructor-arg>
            <value>Hello! 这是singletonBean!value>
        </constructor-arg>
   </ bean>

    <bean id="itxxzBean" class="com.itxxz.HelloItxxz"
        singleton="false">
        <constructor-arg>
            <value>Hello! 这是itxxzBean! value>
        </constructor-arg>
    </bean>

</beans>
```

### 第二种：工厂方法（Factory Method）

通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。

一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。

螃蟹就以工厂方法中的静态方法为例讲解一下：



```cpp
import java.util.Random;
public class StaticFactoryBean {
      public static Integer createRandom() {
           return new Integer(new Random().nextInt());
       }
}
```

建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称



```csharp
<bean id="random"
class="example.chapter3.StaticFactoryBean"
factory-method="createRandom" //createRandom方法必须是static的,才能找到
scope="prototype"
/>
```

测试：



```csharp
public static void main(String[] args) {
      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例
      XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource("config.xml"));
      System.out.println("我是IT学习者创建的实例:"+factory.getBean("random").toString());
}
```

### 第三种：单例模式（Singleton）

保证一个类仅有一个实例，并提供一个访问它的全局访问点。
 spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。
 **核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定**

### 第四种：适配器（Adapter）

在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。

**Adapter类接口**：Target



```java
public interface AdvisorAdapter {

boolean supportsAdvice(Advice advice);

      MethodInterceptor getInterceptor(Advisor advisor);

}
```

**MethodBeforeAdviceAdapter类**，Adapter



```java
class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {

      public boolean supportsAdvice(Advice advice) {
            return (advice instanceof MethodBeforeAdvice);
      }

      public MethodInterceptor getInterceptor(Advisor advisor) {
            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
      return new MethodBeforeAdviceInterceptor(advice);
      }
}
```

说到这里，也给大家推荐一个架构交流学习群：614478470，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。**[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 第五种：包装器（Decorator）

在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？
 首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。
 spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。

### 第六种：代理（Proxy）

为其他对象提供一种代理以控制对这个对象的访问。

从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。
 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。

### 第七种：观察者（Observer）

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
 spring中Observer模式常用的地方是listener的实现。如ApplicationListener。

### 第八种：策略（Strategy）

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。



spring中在实例化对象的时候用到Strategy模式在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： 

![img](https:////upload-images.jianshu.io/upload_images/13317307-bc5c60f7abf983ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/728/format/webp)

### 第九种：模板方法（Template Method）

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
 Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

以下是一个具体的例子：
 JdbcTemplate中的execute方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

以下是一个具体的例子：
 JdbcTemplate中的execute方法 

![img](https:////upload-images.jianshu.io/upload_images/13317307-db5895f58ed508b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)

  JdbcTemplate执行execute方法

![img](https:////upload-images.jianshu.io/upload_images/13317307-a63aaa1e4c128549.png?imageMogr2/auto-orient/strip|imageView2/2/w/741/format/webp)



### 2 缓存穿透

**2.1 什么是缓存穿透**

正常情况下，我们去查询数据都是存在。那么请求去查询一条压根数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

这种查询不存在数据的现象我们称为缓存穿透。

**2.2 穿透带来的问题**

试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。

**2.3 解决办法**

**2.3.1 缓存空值**

之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。

那么我们就可以为这些key 设置的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null ,就不用在到 数据库中去走一圈了。但是别忘了设置过期时间。

**2.3.2 BloomFilter**

BloomFilter 类似于一个hase set 用来判断某个元素（key）是否存在于某个集合中。具体概念

这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。

这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查 缓存 -> 查 DB。

流程图如下：

![img](https:////upload-images.jianshu.io/upload_images/13317307-76dc4ae74b0244d7.png?imageMogr2/auto-orient/strip|imageView2/2/w/628/format/webp)


**2.4 如何选择**



针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。

针对这种key 异常多，请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。

对于空数据的key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

推荐一个交流学习群：614478470 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 **[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 3 缓存击穿

**3.1 什么是击穿**

缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时 这个key 正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们成为击穿。

**3.2 会带来什么问题**

会造成某一时刻数据库请求量过大，压力剧增。

**3.3 如何解决**

上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

### 4、缓存雪崩

**4.1 什么是缓存雪崩**

缓存的情况是说，当某一时刻发生大规模的缓存失效的情况。比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

**4.2 解决办法**

**4.2.1 事前：使用集群缓存，保证缓存服务的高可用**

这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。

**4.2.2 事中：使用 ehcache 本地缓存 + Hystrix 限流&降级 ,避免 MySQL 被打死的情况发生。**

使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。

使用 Hystrix 进行 限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000 个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑，然后去调用我们自己开发的降级组件（降级）。比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。

**4.2.3 事后：开启 Redis 持久化机制，尽快恢复缓存集群**

一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。





防止雪崩方案如下图所示：

![img](https:////upload-images.jianshu.io/upload_images/13317307-79a1b404511d40d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/620/format/webp)

### 5 热点数据集中失效问题怎么解决

我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

**5.1 解决办法**

**5.1.1 设置不同的失效时间**

为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。比如在一个基础的时间上加上或者减去一个范围内的随机值。

**5.1.2 互斥锁**

结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。



### 一、为什么使用Redis

笔者认为，在项目中使用Redis，主要是从两个角度去考虑：性能和并发。当然，Redis还具备可做分布式锁等功能的其它功能，但如果只是为了分布式锁这些其它功能，完全还有其它中间件（如Zookpeer等）可以代替，并不是非要使用Redis。

因此，这个问题主要从性能和并发两个角度去答：

**1、性能**

如下图所示，我们在碰到需要执行耗时特别久、且结果不频繁变动的SQL时，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

![img](https:////upload-images.jianshu.io/upload_images/13317307-e7b5578ebfbc0d00?imageMogr2/auto-orient/strip|imageView2/2/w/803/format/webp)

题外话：忽然想聊一下这个迅速响应的标准——其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我：“在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”

那么瞬间、刹那、一弹指具体是多少时间呢？

根据《摩诃僧祗律》记载：一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。

那么，经过周密的计算，一瞬间为0.36秒,一刹那有0.018秒，一弹指长达7.2秒。

**2、并发**

如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库。

![img](https:////upload-images.jianshu.io/upload_images/13317307-ff28be7e29c1165a?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp)

### 二、使用Redis有什么缺点

大家用Redis这么久，这个问题是必须要了解的，基本上使用Redis都会碰到一些问题，常见的主要是四方面的问题：

1、缓存和数据库双写一致性问题

2、缓存雪崩问题

3、缓存击穿问题

4、缓存的并发竞争问题

这四个问题，笔者个人觉得在项目中比较常遇见。

给大家推荐一个架构交流学习群：614478470，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。**[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 三、单线程的Redis为什么这么快

这个问题其实是对Redis内部机制的一个考察。其实根据笔者的面试经验，很多人其实都不知道Redis是单线程工作模型。所以，这个问题还是应该要复习一下的。主要是以下三点：

1、纯内存操作

2、单线程操作，避免了频繁的上下文切换

3、采用了非阻塞I/O多路复用机制

我们现在仔细地说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

**经营方式一：**

客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在很多问题，几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递。

随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了，快递员之间的协调很花时间，大部分时间花在抢车上。综合上述缺点，小曲痛定思痛，提出了下面的经营方式↓

**经营方式二：**

小曲只雇佣一个快递员，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次去取快递，一次拿一个，开着车去送快递，送好了就回来拿下一个快递。

上述两种经营方式对比，是不是明显觉得第二种，效率更高、更好呢？在上述比喻中：

1、每个快递员→每个线程

2、每个快递→每个Socket(I/O流)

3、快递的送达地点→Socket的不同状态

4、客户送快递请求→来自客户端的请求

5、小曲的经营方式→服务端运行的代码

6、一辆车→CPU的核数

**于是我们有如下结论：**

1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

下面类比到真实的Redis线程模型，如图所示：

![img](https:////upload-images.jianshu.io/upload_images/13317307-791edbe33ec6022b?imageMogr2/auto-orient/strip|imageView2/2/w/942/format/webp)

参照上图，简单来说就是，我们的Redis-client在操作的时候，会产生具有不同事件类型的Socket。在服务端，有一段I/O多路复用程序，将其置入队列之中。然后文件事件分派器依次去队列中取，转发到不同的事件处理器中。

需要说明的是，这个I/O多路复用机制，Redis还提供了Select、Epoll、Evport、Kqueue等多路复用函数库，大家可以自行去了解。

### 四、Redis的数据类型及各自使用场景

看到这个问题，是不是觉得它很基础？其实笔者也这么觉得。然而根据面试经验发现，至少80%的人答不上这个问题。建议在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员五种类型都会用到：

**1、String**

这个其实没什么好说的，最常规的Set/Get操作，Value可以是String也可以是数字，一般做一些复杂的计数功能的缓存。

**2、Hash**

这里Value存放的是结构化的对象，比较方便的就是操作其中的某个字段。笔者在做单点登录的时候，就是用这种数据结构存储用户信息，以CookieId作为Key，设置30分钟为缓存过期时间，能很好地模拟出类似Session的效果。

**3、List**

使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用Lrange命令，做基于Redis的分页功能，性能极佳，用户体验好。

**4、Set**

因为Set堆放的是一堆不重复值的集合，所以可以做全局去重的功能。

为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set比较麻烦，难道为了做一个全局去重，再起一个公共服务？太麻烦了。

另外，就是利用交集、并集、差集等操作，可以计算共同喜好、全部的喜好、自己独有的喜好等功能。

**5、Sorted Set**

Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，取TOP N操作。另外，Sorted Set还可以用来做延时任务。最后一个应用就是可以做范围查找。

### 五、Redis的过期策略及内存淘汰机制

这个问题其实相当重要，从这个问题就可以看出来到底Redis有没有用到位。比如，你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?

Redis采用的是定期删除+惰性删除策略。

为什么不用定时删除策略？

**定时删除，**用一个定时器来负责监视Key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除Key，因此没有采用这一策略。

定期删除+惰性删除是如何工作的呢？

**定期删除，**Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。

于是，惰性删除派上用场。也就是说在你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么？

不是的，如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。

在Redis.conf中有一行配置：

# maxmemory-policy volatile-lru

该配置就是配内存淘汰策略的：

**Noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；

**Allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的Key。推荐使用，目前项目在用这种；

**Allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；

**Volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；

**Volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个Key。依然不推荐；

**Volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。

PS：如果没有设置Expire的Key，不满足先决条件（Prerequisites）；那么Volatile-lru、Volatile-random和Volatile-ttl策略的行为，和Noeviction（不删除）基本上一致。

### 六、Redis和数据库双写一致性问题

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题，想要回答这个问题，就要先明白一个前提：如果对数据有强一致性要求，就不能放缓存。我们所做的一切，只能保证最终一致性。

另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据不能放缓存。

给出了详细的分析，在这里简单地说一说：首先，采取正确更新策略，先更新数据库，再删缓存；其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

### 七、应对缓存穿透和缓存雪崩问题

关于“如何应对缓存穿透和缓存雪崩”这两个问题，说句实在话，一般中小型传统软件企业很难碰到。如果有大并发的项目，流量有几百万左右，这两个问题一定要深刻考虑：

**1、应对缓存穿透**

缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

解决方案：

利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库，没得到锁，则休眠一段时间重试；

1、采用异步更新策略，无论Key是否取到值，都直接返回。Value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存，需要做缓存预热（项目启动前，先加载缓存）操作；

2、提供一个能迅速判断请求是否有效的拦截机制，比如利用布隆过滤器，内部维护一系列合法有效的Key，迅速判断出，请求所携带的Key是否合法有效，如果不合法，则直接返回。

2、应对缓存雪崩

缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

解决方案：

1、给缓存的失效时间加上一个随机值，避免集体失效；

2、使用互斥锁，但是该方案吞吐量明显下降了；

3、双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间，自己做缓存预热操作。

然后细分以下几个小点：

a. 从缓存A读数据库，有则直接返回；

b. A 没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程；

c. 更新线程同时更新缓存A和缓存B。

### 八、如何解决Redis并发竞争Key问题

这个问题大致就是同时有多个子系统去Set一个Key。这个时候要注意什么呢？本人提前百度了一下，发现大家思考的答案基本都是推荐用Redis事务机制。但本人不推荐使用Redis的事务机制。因为我们的生产环境，基本都是Redis集群环境，做了数据分片操作。你一个事务中有涉及到多个Key操作的时候，这多个Key不一定都存储在同一个Redis-Server上。因此，Redis的事务机制，十分鸡肋。

解决方法如下：

如果对这个Key操作不要求顺序

这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做Set操作即可，比较简单。

如果对这个Key操作要求顺序

假设有一个Key1，系统A需要将Key1设置为ValueA，系统B需要将Key1设置为ValueB，系统C需要将Key1设置为ValueC。期望按照Key1的Value值按照 ValueA→ValueB→ValueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下：

1、系统A Key 1 {ValueA  3:00}

2、系统B Key 1 {ValueB  3:05}

3、系统C Key 1 {ValueC  3:10}

那么，假设这会系统B先抢到锁，将Key1设置为{ValueB 3:05}。接下来系统A抢到锁，发现自己的ValueA的时间戳早于缓存中的时间戳，那就不做Set操作了。以此类推。

其他方法，比如利用队列，将Set方法变成串行访问也可以。总之，灵活变通。

**1.在你知道必要之前不要优化**

这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。

在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。

那么，你如何证明你需要优化一些东西呢？

首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。

**2.使用分析器查找真正的瓶颈**

在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？

你可以用两种方法来解决问题：

- 查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。
- 或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。

希望不需要我解释为什么应该始终遵循第二种方法的原因。

很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。老实说，我第一次的猜测不止一次地导致我走错了方向。

**3.为整个应用程序创建性能测试套件**

这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。

这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。

**4.首先处理最大的瓶颈**

在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。这个你也必须会。

速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。

但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。

常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。

工作一到五年的 Java 的工程师朋友们加入 Java 架构开发群：614478470
 就可以马上免费获得这套内部教材！ [点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)

**5.使用StringBuilder以编程方式连接String**

有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。

那么，你应该选择哪种方法？

答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。这个你必须清楚。

你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。

下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。



```go
StringBuilder sb = new StringBuilder(“This is a test”);
for (int i=0; i<10; i++) {
sb.append(i);
sb.append(” “);
}
log.info(sb.toString());
```

正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。

如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。这进一步提高了效率，因为它不需要动态扩展其容量。

**6.使用+连接一个语句中的String**

当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。

在这些情况下，你应该遵循技巧5并使用StringBuilder。

但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。



```objectivec
Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ”
+ “FROM Author a ”
+ “WHERE a.id = :id”);
```

在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。

**7.尽可能使用基元**

避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。

**8.试着避免BigInteger和BigDecimal**

既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。

BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。这个你了解下。

**9.首先检查当前日志级别**

这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。

这里有两个反面例子。



```dart
// don’t do this
log.debug(“User [” + userName + “] called method X with [” + i + “]”);

// or this
log.debug(String.format(“User [%s] called method X with [%d]”, userName, i));
```

在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。因此在创建调试消息之前，最好先检查当前的日志级别。



```cpp
// do this
if (log.isDebugEnabled()) { 
  log.debug(“User [” + userName + “] called method X with [” + i + “]”);
}
```

**10.使用Apache Commons StringUtils.Replace而不是String.replace**

一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。

有一个备选答案是Apache Commons Lang的StringUtils.replace方法。正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。

而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。



```bash
// replace this
test.replace(“test”, “simple test”);

// with this
StringUtils.replace(test, “test”, “simple test”);
```

**11.缓存昂贵的资源，如数据库连接**

缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。

一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。

你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。

但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。

所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们

