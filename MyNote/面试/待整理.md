# 数据结构和算法

1. B+树
2. 快速排序，堆排序，插入排序（其实八大排序算法都应该了解
3. 一致性Hash算法，一致性Hash算法的应用

# JVM

14. dump文件的分析。

# 框架相关

## SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。

##  Mybatis如何找到指定的Mapper的，如何完成查询的。 

## Quartz是如何完成定时任务的。 

## Spring的IOC有什么优势。 

## Spring如何维护它拥有的bean。 

# **Java IO 和 NIO 的面试题**

IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。

**66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？**

**67）Java 中怎么创建 ByteBuffer？**

**68）Java 中，怎么读写 ByteBuffer ？**

**69）Java 采用的是大端还是小端？**

**70）ByteBuffer 中的字节序是什么？**

**71）Java 中，直接缓冲区与非直接缓冲器有什么区别？**

**72）Java 中的内存映射缓存区是什么？**

**73）socket 选项 TCP NO DELAY 是指什么？**

**74）TCP 协议与 UDP 协议有什么区别？**

**75）Java 中，ByteBuffer 与 StringBuffer有什么区别？**

# **Java 最佳实践的面试问题**

包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。

**76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？**

这是我在写Java 并发程序的时候遵循的一些最佳实践：

a）给线程命名，这样可以帮助调试。

b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。

c）如果可以，更偏向于使用 volatile 而不是 synchronized。

d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。

e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。

**77）说出几点 Java 中使用 Collections 的最佳实践**

这是我在使用 Java 中 Collectionc 类的一些最佳实践：

a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。

b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。

c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。

d）使用迭代器来循环集合。

e）使用集合的时候使用泛型。

**78）说出至少 5 点在 Java 中使用线程的最佳实践。**

这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：

a）对线程命名

b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。

c）使用线程池

**79）说出 5 条 IO 的最佳实践**

IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：

a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。

b）使用 NIO 和 NIO2

c）在 finally 块中关闭流，或者使用 try-with-resource 语句。

d）使用内存映射文件获取更快的 IO。

**80）列出 5 个应该遵循的 JDBC 最佳实践**

有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：

a）使用批量的操作来插入和更新数据

b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。

c）使用数据库连接池

d）通过列名来获取结果集，不要使用列的下标来获取。

**81）说出几条 Java 中方法重载的最佳实践？**

下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。

a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。

b）不要重载参数数量一致，而只是参数顺序不同的方法。

c）如果重载的方法参数个数多于 5 个，采用可变参数。

Date、Time 及 Calendar 的面试题

**82）在多线程环境下，SimpleDateFormat 是线程安全的吗？**

不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

**83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？**

Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。

**84）Java 中，怎么在格式化的日期中显示时区？**

**85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？**

**86）Java 中，如何计算两个日期之间的差距？**

**87）Java 中，如何将字符串 YYYYMMDD 转换为日期？**

# **单元测试 JUnit 面试题**

**89）如何测试静态方法？**

可以使用 PowerMock 库来测试静态方法。

**90）怎么利用 JUnit 来测试一个方法的异常？**

**91）你使用过哪个单元测试库来测试你的 Java 程序？**

**92）@Before 和 @BeforeClass 有什么区别？**

# **编程和代码相关的面试题**

93）怎么检查一个字符串只包含数字？

94）Java 中如何利用泛型写一个 LRU 缓存？

95）写一段 Java 程序将 byte 转换为 long？

95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？

97）Java 中，怎么获取一个文件中单词出现的最高频率？

98）如何检查出两个给定的字符串是反序的？

99）Java 中，怎么打印出一个字符串的所有排列？

100）Java 中，怎样才能打印出数组中的重复元素？

101）Java 中如何将字符串转换为整数？

102）在没有使用临时变量的情况如何交换两个整数变量的值？

# **关于 OOP 和设计模式的面试题**

这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。

**103）接口是什么？为什么要使用接口而不是直接使用具体类？**

接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。

**104）Java 中，抽象类与接口之间有什么不同？**

Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。

**105）除了单例模式，你在生产环境中还用过什么设计模式？**

这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。

**106）你能解释一下里氏替换原则吗?**

**107) 什么情况下会违反迪米特法则？为什么会有这个问题？**

迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。

**108）适配器模式是什么？什么时候使用？**

适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。

**109）什么是“依赖注入”和“控制反转”？为什么有人使用？**

**110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？**

**111）构造器注入和 setter 依赖注入，那种方式更好？**

每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。

**112）依赖注入和工程模式之间有什么不同？**

虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。

**113）适配器模式和装饰器模式有什么区别？**

虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

**114）适配器模式和代理模式之前有什么不同？**

这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

**115）什么是模板方法模式？**

模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。

**116）什么时候使用访问者模式？**

访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。

**117）什么时候使用组合模式？**

组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。

**118）继承和组合之间有什么不同？**

虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。

**119）描述 Java 中的重载和重写？**

重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。

**120）Java 中，嵌套公共静态类与顶级类有什么不同？**

类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。

**121) OOP 中的 组合、聚合和关联有什么区别？**

如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。

**122）给我一个符合开闭原则的设计模式的例子？**

开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。

**123）抽象工厂模式和原型模式之间的区别？**

**124）什么时候使用享元模式？**

享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。

### 1、什么是 SpringMvc？

答：SpringMvc 是 spring 的一个模块，基于 MVC 的一个框架，无需中间整合层来整

### 2、Spring MVC 的优点：

答：

1）它是基于组件技术的.全部的应用对象,无论控制器和视图,还是业务对象之类的都是 组件.并且和 Spring 提供的其他基础结构紧密集成.

2）不依赖于 Servlet API(目标虽是如此,但是在实现的时候确实是依赖于 Servlet 的)3）可以任意使用各种视图技术,而不仅仅局限于 JSP4）支持各种请求资源的映射策略5）它应是易于扩展的

### 3、SpringMVC 工作原理？

答：

1）客户端发送请求到 DispatcherServlet

2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller

3）Controller 调用业务逻辑后，返回 ModelAndView

4）DispatcherServlet 查询 ModelAndView，找到指定视图

5）视图将结果返回到客户端

### 4、SpringMVC 流程？

答：

1）用户发送请求至前端控制器 DispatcherServlet。

2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。

3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。

4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。

5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)

6）Controller 执行完成返回 ModelAndView。

7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。

9）ViewReslover 解析后返回具体 View。

10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。

11）DispatcherServlet 响应用户。

### 6、SpringMvc 的控制器是不是单例模式,如果是,有什么问题,怎么解决？

答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解方案是在控制器里面不能写字段。

### 8、SpingMvc 中的控制器的注解一般****用那个****,有没有别的注解可以替代

答：一般用@Conntroller 注解,表示是表现层,不能用用别的注解代替

### 9、 @RequestMapping 注解用在类上面有什么作用？

答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类有响应请求的方法都是以该地址作为父路径。

### 10、怎么样把某个请求映射到特定的方法上面？

答：直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路

### 11、如果在拦截请求中,我想拦截 get 方式提交的方法,怎么配置？

答：可以在@RequestMapping 注解里面加上 method=RequestMethod.GET

### 12、怎么样在方法里面得到 Request,或者 Session？

答：直接在方法的形参中声明 request,SpringMvc 就自动把 request 对象传

### 13、我想在拦截的方法里面得到从前台传入的参数,怎么得到？

答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样

### 14、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这象？

答：直接在方法中声明这个对象,SpringMvc 就自动会把属性赋值到这个对象里面。

### 15、SpringMvc 中函数的返回值是什么？

答：返回值可以有很多类型,有 String, ModelAndView,当一般用 String 比较好

### 16、SpringMVC 怎么样设定重定向和转发的？

答：在返回值前面加"forward:"就可以让结果转发,譬如"forward:user.do?name=method4返回值前面加"redirect:"就可以让返回值重定向,譬如"redirect:百度一下，你就知道"

### 17、SpringMvc 用什么对象从后台向前台传递数据的？

答：通过 ModelMap 对象,可以在这个对象里面用 put 方法,把对象加到里面,前台就可以过 el 表达式拿到。

### 18、SpringMvc 中有个类把视图和数据都合并的一起的,叫什么？

答：叫 ModelAndView。

### 19、怎么样把 ModelMap 里面的数据放入 Session 里面？

答：可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 的 key

### 20、SpringMvc 怎么和 AJAX 相互调用的？

答：通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象具体步骤如下 ：

1）加入 Jackson.jar

2）在配置文件中配置 json 的映射

3）在接受 Ajax 方法里面可以直接返回 Object,List 等,但方法前面要加上@ResponseB注解

### 21、当一个方法向 AJAX 返回特殊对象,譬如 Object,List 等,需要做什么处理？

答：要加上@ResponseBody 注解

### 22、SpringMvc 里面拦截器是怎么写的？

答：有两种写法,一种是实现接口,另外一种是继承适配器类,然后在 SpringMvc 的配置文配置拦截器即可：mvc:interceptors

<mvc:mapping path="/modelMap.do" />

</mvc:interceptor></mvc:interceptors>

#### JAVA

5个常用的java-api包。
 String类中常用的5个方法。
 API接口开发的注意事项。
 TCP/IP、HTTP协议。

#### 集合相关的问题(重点)

HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap、ArrayList、LinkedList的实现和区别之类的。
 上述集合中的那些是线程安全的，那些不是。
 在那些场景使用这些集合。
 List、Map、Set三个接口，存取元素时，各有什么特点。

#### 线程相关问题（重点）

创建线程的几种方式。
 线程同步的方法。
 wait和sleep区别。
 Runnable接口和Callable接口的区别。
 如何实现线程安全。

#### 框架相关知识（这块反而不多）

Mybatis#和$的区别.
 Hibernate和Mybatis的区别。
 Spring MVC和Struts2的区别.
 Hibernate的缓存机制。
 什么是Hibernate延迟加载.
 为什么要用spring。

#### SQL(主要考察Group by和Order by相关知识)

查询每个班级成绩最高的学生。
 查找出每个班级成绩第二的学生。
 按照班级查询每个班上总分前三的学生。
 查找入职员工时间排名倒数第三的员工所有信息。
 薪水排序后薪水排名在第2--8的员工。
 按工资进行排名，排名从1开始，工资相同排名相同（如果两人并列第一则没有第二名，从第三名继续排）。
 用一条sql语句取出所有姓名有重复的学员姓名和重复的记录数。

#### JavaScript/JSP/Servet （这些一般是基础题）

JSP的内置对象以及作用。
 JSTL的常用标签。
 Servlet的生命周期。
 URL和URI的区别。
 Ajax同步和异步的区别。
 使用ajax发送异步请求的流程。

#### 其它

&和&&的区别。
 ==和equals的区别。
 int和Integer的自动拆箱/装箱相关问题。
 IO和NIO的区别。
 final、finally、finalize的区别。
 重载（Overload）和重写（Override）的区别。
 String、StringBuffer和StringBuilder的区别。
 如何实现浅克隆和深克隆。
 单例模式的实现以及最优。
 排序的实现（冒泡、选择、快速等）。
 去除重复的元素(实际是重写equals和hashcode)。

## 阿里面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-c8f86ed3d4e79f75.png?imageMogr2/auto-orient/strip|imageView2/2/w/563/format/webp)

- 多个线程同时读写，读线程的数量远远大于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？
- JAVA的AQS是否了解，它是干嘛的？
- 除了synchronized关键字之外，你是怎么来保障线程安全的？
- Tomcat本身的参数你一般会怎么调整？
- 你有没有用过Spring的AOP? 是用来干嘛的? 大概会怎么使用？
- 如果一个接口有2个不同的实现, 那么怎么来Autowire一个指定的实现？
- 如果想在某个Bean生成并装配完毕后执行自己的逻辑，可以什么方式实现？
- SpringBoot没有放到web容器里为什么能跑HTTP服务？
- SpringBoot中如果你想使用自定义的配置文件而不仅仅是application.properties，应该怎么弄？
- SpringMVC如果希望把输出的Object(例如XXResult或者XXResponse)这种包装为JSON输出, 应该怎么处理?
- 如果有很多数据插入MYSQL 你会选择什么方式?
- 如果查询很慢，你会想到的第一个方式是什么？索引是干嘛的?
- 查询死掉了，想要找出执行的查询进程用什么命令？找出来之后一般你会干嘛？
- 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有什么关系？
- 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正确的？
- 你知道哪些或者你们线上使用什么GC策略? 它有什么优势，适用于什么场景？
- JAVA类加载器包括几种？它们之间的父子关系是怎么样的？双亲委派机制是什么意思？有什么好处？
- 如何自定义一个类加载器？你使用过哪些或者你在什么场景下需要一个自定义的类加载器吗？
- 堆内存设置的参数是什么？
- HashMap和Hashtable的区别。
- 实现一个保证迭代顺序的HashMap。
- 说一说排序算法，稳定性，复杂度。
- 说一说GC。
- JVM如何加载一个类的过程，双亲委派模型中有哪些方法？
- TCP如何保证可靠传输？三次握手过程？

## 京东面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-c9edc37198239259.png?imageMogr2/auto-orient/strip|imageView2/2/w/502/format/webp)

- java常用的数据结构有哪些?哪些是线程安全的?是怎么保证线程安全的？
- Redis中的Lua有没有使用过? 可以用来做什么? 为什么可以这么用?
- 线程池内部工作原理可以说一下么？
- 死锁是什么意思，形成条件是什么？出现死锁是可以通过什么方式去排查。
- 在交易过程中如何放在用户在支付时的重复支付（交叉支付），请写出你了解的方案或使用的过的方案。
- 数据库索引有哪几种，他们之间的区别。
- 程序开发时通过开发工具DeBug调试时，控制台显示的内容都包含什么？哪些内容可以帮助你发现问题和解决问题。
- RPC通信过程中，假设A系统提供了一个方法入参是一个JavaBean，出参也是一个JavaBean。另外两个系统B系统、C系统调用接口，调用方B想让提供方A增加一个返回参数，假设服务提供方A增加了返回参数，请问C系统调用方需要做什么处理？
- 了解哪些设计模式，用伪代码实现一个你熟悉的设计模式。
- 讲一下怎么使用分布式锁。
- 说说HashMap的原理, 以及HashMap如何扩充bucket的大小。
- Redis的Pipeline是用来干什么的?
- Mysql索引的分类(Btree, hash)，各自使用什么情况 。
- 说说Myisam, Innodb区别。
- 知道哪些负载均衡算法。
- 说一下Btree的查找原理。
- 简述三次握手，如果c端发起握手请求，s端无法立刻建立连接应该回应什么？

说到这里，也给大家推荐一个架构交流学习群：614478470 **[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。合理利用自己每一分每一秒的时间来学习提升自己，不要再用"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！

## 去哪儿网面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-bc81f98acec104b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

- 自我介绍，项目介绍。
- mysql数据库调优。
- sql优化。
- like能用索引吗？
- java对象四种引用。
- GC原理。
- jvm内存结构。
- 说一下你学过jvm 在书写代码上对你有什么帮助和提高。
- 千万数据量的查询你会怎么做？
- HashMap在jdk1.7和1.8的区别，为什么引入这个概念？hash碰撞怎么解决，为什么1.8要比1.7更好，好在哪？
- 关于你的项目，如果并发很大，你会怎么改造。
- 方法区里什么样的对象有可能被回收。
- 线上cpu飙升100%你怎么处理。
- 频繁FullGC怎么处理。
- 线程池创建有几种，为什么创建定长的线程池个数最好是5，10，15这样的数字。
- linux命令。
- 伊甸区和幸存区可动态变化吗？
- redis和memcached区别。
- 说几个jdk命令，jmap是什么意思。
- 如果并发很大，你对数据的正确性怎么保证。

## 饿了么面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-3fb6fd1bb46491ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/533/format/webp)

- http和https的区别，https原理，http2.0与1.0的区别。
- Java的垃圾回收机制，Java文件加载机制，tomcat类加载机制，锁机制，jvm原理及线上调优，jvm内存模型。
- 多线程，有哪些可以保持进程同步的方法，创建线程的几种方法，对i++多线程访问你会怎么做。
- Java的设计模式，单例有什么模式，懒汉为什么加volotile，volotile的内存屏障，如何避免死锁。
- 考虑单例模式的编写，要线程安全且内存消耗小（剑指offer原题）。
- String、StringBuilder、StringBuffer区别；String类能被继承吗？为什么？
- 在白纸上手写二分法排序算法（lintcode上原题）；二分查找的思想。
- 查找单链表中倒数第k个节点的算法，手写（lintcode上原题）；最常见的排序算法你见过哪些，快排的基本思想及时间复杂度。
- 常见的数据结构有哪些。
- hashmap、hashcode一样，不equals怎么处理 ；hashcode实现原理，currentHashMap原理，实现细节，怎么实现同步的；类为什么要有hascode方法，是不是主要在集合类中都要实现hashcode方法；equals方法怎么实现；两个不同的对象可能有相同的hashcode值吗；常用集合有哪些。
- tcp三次握手，四次挥手协议。
- 架构设计一个开发性问题，设计一个Nginx管理的中间件，怎么设计。
- 所有的类都继承与object，你用过object类的直接子类有哪些，object类常用的方法有哪些。
- Java会出现内存泄漏吗，如果回，在哪种情况下？
- 抽象类和接口的区别。
- 平时怎么扩展自己的专业知识水平。

## 百度面试题

![img](https:////upload-images.jianshu.io/upload_images/13317307-9fde129a839640a5.png?imageMogr2/auto-orient/strip|imageView2/2/w/516/format/webp)

- 什么是 Java 的反射机制。
- Cookie 和 Session的区别。
- get 和 post请求的区别。
- IOC的优点是什么。
- IO 和 NIO的区别，NIO优点。
- JRE、JDK、JVM 及 JIT 之间有什么不同。
- Hashcode 的作用。
- 简述一致性 Hash 算法。
- 为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里。
- 为什么 Map 接口不继承 Collection 接口。
- 说出几点 Java 中使用 Collections 的最佳实践？
- GC是什么？为什么要有GC。
- 什么时候会导致垃圾回收。
- GC 有几种方式？怎么配置。
- 什么时候一个对象会被GC？ 如何判断一个对象是否存活。
- 垃圾回收器的基本原理是什么？
- Serial 与 Parallel GC之间的不同之处。
- JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代。
- 吞吐量优先和响应优先的垃圾收集器选择。
- 说说你知道的几种主要的jvm 参数。
- Java中存在内存泄漏问题吗？请举例说明。
- 什么是线程，多线程的优点是什么？以及简单说一下多线程的几种实现方式。
- ThreadLocal 用途是什么，原理是什么，用的时候要注意什么?
- 线程池是什么？为什么要使用它？如何创建一个Java线程池？
- ThreadPool用法与优势可以说一下么？
- synchronized 的原理是什么？synchronized 和 ReentrantLock 有什么不同？
- 有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行同步块内的线程抛出异常会发生什么？
- 什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题。
- Java中活锁和死锁有什么区别？
- Executors类是什么？ Executor和Executors的区别？
- 什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合？
- 你能写出三种单例模式实现么？
- 你知道Google是如何在一秒内把搜索结果返回给用户？
- 高并发下，如何做到安全的修改同一行数据？
- 如何避免浏览器缓存。
- 大型网站在架构上应当考虑哪些问题？
- 最近有在看什么书么，印象最深刻的是什么？
- 你们线上应用的 JVM 参数有哪些？
- 能简单说下你对算法的理解么？

# 我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？

为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：**自动配置。**



设计模式作为工作学习中的枕边书，却时常处于勤说不用的尴尬境地，也不是我们时常忘记，只是一直没有记忆。

今天，在IT学习者网站就设计模式的内在价值做一番探讨，并以spring为例进行讲解，只有领略了其设计的思想理念，才能在工作学习中运用到“无形”。

Spring作为业界的经典框架，无论是在架构设计方面，还是在代码编写方面，都堪称行内典范。好了，话不多说，开始今天的内容。

spring中常用的设计模式达到九种，我们一一举例：

### 第一种：简单工厂

又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。

简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。
 spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。



```xml
<beans>
    <bean id="singletonBean" class="com.itxxz.HelloItxxz">
        <constructor-arg>
            <value>Hello! 这是singletonBean!value>
        </constructor-arg>
   </ bean>

    <bean id="itxxzBean" class="com.itxxz.HelloItxxz"
        singleton="false">
        <constructor-arg>
            <value>Hello! 这是itxxzBean! value>
        </constructor-arg>
    </bean>

</beans>
```

### 第二种：工厂方法（Factory Method）

通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。

一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。

螃蟹就以工厂方法中的静态方法为例讲解一下：



```cpp
import java.util.Random;
public class StaticFactoryBean {
      public static Integer createRandom() {
           return new Integer(new Random().nextInt());
       }
}
```

建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称



```csharp
<bean id="random"
class="example.chapter3.StaticFactoryBean"
factory-method="createRandom" //createRandom方法必须是static的,才能找到
scope="prototype"
/>
```

测试：



```csharp
public static void main(String[] args) {
      //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例
      XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource("config.xml"));
      System.out.println("我是IT学习者创建的实例:"+factory.getBean("random").toString());
}
```

### 第三种：单例模式（Singleton）

保证一个类仅有一个实例，并提供一个访问它的全局访问点。
 spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。
 **核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定**

### 第四种：适配器（Adapter）

在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。

**Adapter类接口**：Target



```java
public interface AdvisorAdapter {

boolean supportsAdvice(Advice advice);

      MethodInterceptor getInterceptor(Advisor advisor);

}
```

**MethodBeforeAdviceAdapter类**，Adapter



```java
class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {

      public boolean supportsAdvice(Advice advice) {
            return (advice instanceof MethodBeforeAdvice);
      }

      public MethodInterceptor getInterceptor(Advisor advisor) {
            MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
      return new MethodBeforeAdviceInterceptor(advice);
      }
}
```

说到这里，也给大家推荐一个架构交流学习群：614478470，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。**[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 第五种：包装器（Decorator）

在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？
 首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。
 spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。

### 第六种：代理（Proxy）

为其他对象提供一种代理以控制对这个对象的访问。

从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。
 spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。

### 第七种：观察者（Observer）

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
 spring中Observer模式常用的地方是listener的实现。如ApplicationListener。

### 第八种：策略（Strategy）

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。



spring中在实例化对象的时候用到Strategy模式在SimpleInstantiationStrategy中有如下代码说明了策略模式的使用情况： 

![img](https:////upload-images.jianshu.io/upload_images/13317307-bc5c60f7abf983ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/728/format/webp)

### 第九种：模板方法（Template Method）

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
 Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

以下是一个具体的例子：
 JdbcTemplate中的execute方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。

以下是一个具体的例子：
 JdbcTemplate中的execute方法 

![img](https:////upload-images.jianshu.io/upload_images/13317307-db5895f58ed508b3.png?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)

  JdbcTemplate执行execute方法

![img](https:////upload-images.jianshu.io/upload_images/13317307-a63aaa1e4c128549.png?imageMogr2/auto-orient/strip|imageView2/2/w/741/format/webp)



### 2 缓存穿透

**2.1 什么是缓存穿透**

正常情况下，我们去查询数据都是存在。那么请求去查询一条压根数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

这种查询不存在数据的现象我们称为缓存穿透。

**2.2 穿透带来的问题**

试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。

**2.3 解决办法**

**2.3.1 缓存空值**

之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。

那么我们就可以为这些key 设置的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null ,就不用在到 数据库中去走一圈了。但是别忘了设置过期时间。

**2.3.2 BloomFilter**

BloomFilter 类似于一个hase set 用来判断某个元素（key）是否存在于某个集合中。具体概念

这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。

这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查 缓存 -> 查 DB。

流程图如下：

![img](https:////upload-images.jianshu.io/upload_images/13317307-76dc4ae74b0244d7.png?imageMogr2/auto-orient/strip|imageView2/2/w/628/format/webp)


**2.4 如何选择**



针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。

针对这种key 异常多，请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。

对于空数据的key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

推荐一个交流学习群：614478470 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 **[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 3 缓存击穿

**3.1 什么是击穿**

缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时 这个key 正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们成为击穿。

**3.2 会带来什么问题**

会造成某一时刻数据库请求量过大，压力剧增。

**3.3 如何解决**

上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

### 4、缓存雪崩

**4.1 什么是缓存雪崩**

缓存的情况是说，当某一时刻发生大规模的缓存失效的情况。比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

**4.2 解决办法**

**4.2.1 事前：使用集群缓存，保证缓存服务的高可用**

这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。

**4.2.2 事中：使用 ehcache 本地缓存 + Hystrix 限流&降级 ,避免 MySQL 被打死的情况发生。**

使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。

使用 Hystrix 进行 限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000 个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑，然后去调用我们自己开发的降级组件（降级）。比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。

**4.2.3 事后：开启 Redis 持久化机制，尽快恢复缓存集群**

一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。





防止雪崩方案如下图所示：

![img](https:////upload-images.jianshu.io/upload_images/13317307-79a1b404511d40d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/620/format/webp)

### 5 热点数据集中失效问题怎么解决

我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

**5.1 解决办法**

**5.1.1 设置不同的失效时间**

为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。比如在一个基础的时间上加上或者减去一个范围内的随机值。

**5.1.2 互斥锁**

结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。



### 一、为什么使用Redis

笔者认为，在项目中使用Redis，主要是从两个角度去考虑：性能和并发。当然，Redis还具备可做分布式锁等功能的其它功能，但如果只是为了分布式锁这些其它功能，完全还有其它中间件（如Zookpeer等）可以代替，并不是非要使用Redis。

因此，这个问题主要从性能和并发两个角度去答：

**1、性能**

如下图所示，我们在碰到需要执行耗时特别久、且结果不频繁变动的SQL时，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

![img](https:////upload-images.jianshu.io/upload_images/13317307-e7b5578ebfbc0d00?imageMogr2/auto-orient/strip|imageView2/2/w/803/format/webp)

题外话：忽然想聊一下这个迅速响应的标准——其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我：“在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”

那么瞬间、刹那、一弹指具体是多少时间呢？

根据《摩诃僧祗律》记载：一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。

那么，经过周密的计算，一瞬间为0.36秒,一刹那有0.018秒，一弹指长达7.2秒。

**2、并发**

如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库。

![img](https:////upload-images.jianshu.io/upload_images/13317307-ff28be7e29c1165a?imageMogr2/auto-orient/strip|imageView2/2/w/732/format/webp)

### 二、使用Redis有什么缺点

大家用Redis这么久，这个问题是必须要了解的，基本上使用Redis都会碰到一些问题，常见的主要是四方面的问题：

1、缓存和数据库双写一致性问题

2、缓存雪崩问题

3、缓存击穿问题

4、缓存的并发竞争问题

这四个问题，笔者个人觉得在项目中比较常遇见。

给大家推荐一个架构交流学习群：614478470，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。**[点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)**

### 三、单线程的Redis为什么这么快

这个问题其实是对Redis内部机制的一个考察。其实根据笔者的面试经验，很多人其实都不知道Redis是单线程工作模型。所以，这个问题还是应该要复习一下的。主要是以下三点：

1、纯内存操作

2、单线程操作，避免了频繁的上下文切换

3、采用了非阻塞I/O多路复用机制

我们现在仔细地说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

**经营方式一：**

客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在很多问题，几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递。

随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了，快递员之间的协调很花时间，大部分时间花在抢车上。综合上述缺点，小曲痛定思痛，提出了下面的经营方式↓

**经营方式二：**

小曲只雇佣一个快递员，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次去取快递，一次拿一个，开着车去送快递，送好了就回来拿下一个快递。

上述两种经营方式对比，是不是明显觉得第二种，效率更高、更好呢？在上述比喻中：

1、每个快递员→每个线程

2、每个快递→每个Socket(I/O流)

3、快递的送达地点→Socket的不同状态

4、客户送快递请求→来自客户端的请求

5、小曲的经营方式→服务端运行的代码

6、一辆车→CPU的核数

**于是我们有如下结论：**

1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

下面类比到真实的Redis线程模型，如图所示：

![img](https:////upload-images.jianshu.io/upload_images/13317307-791edbe33ec6022b?imageMogr2/auto-orient/strip|imageView2/2/w/942/format/webp)

参照上图，简单来说就是，我们的Redis-client在操作的时候，会产生具有不同事件类型的Socket。在服务端，有一段I/O多路复用程序，将其置入队列之中。然后文件事件分派器依次去队列中取，转发到不同的事件处理器中。

需要说明的是，这个I/O多路复用机制，Redis还提供了Select、Epoll、Evport、Kqueue等多路复用函数库，大家可以自行去了解。

### 四、Redis的数据类型及各自使用场景

看到这个问题，是不是觉得它很基础？其实笔者也这么觉得。然而根据面试经验发现，至少80%的人答不上这个问题。建议在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员五种类型都会用到：

**1、String**

这个其实没什么好说的，最常规的Set/Get操作，Value可以是String也可以是数字，一般做一些复杂的计数功能的缓存。

**2、Hash**

这里Value存放的是结构化的对象，比较方便的就是操作其中的某个字段。笔者在做单点登录的时候，就是用这种数据结构存储用户信息，以CookieId作为Key，设置30分钟为缓存过期时间，能很好地模拟出类似Session的效果。

**3、List**

使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用Lrange命令，做基于Redis的分页功能，性能极佳，用户体验好。

**4、Set**

因为Set堆放的是一堆不重复值的集合，所以可以做全局去重的功能。

为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set比较麻烦，难道为了做一个全局去重，再起一个公共服务？太麻烦了。

另外，就是利用交集、并集、差集等操作，可以计算共同喜好、全部的喜好、自己独有的喜好等功能。

**5、Sorted Set**

Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，取TOP N操作。另外，Sorted Set还可以用来做延时任务。最后一个应用就是可以做范围查找。

### 五、Redis的过期策略及内存淘汰机制

这个问题其实相当重要，从这个问题就可以看出来到底Redis有没有用到位。比如，你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?

Redis采用的是定期删除+惰性删除策略。

为什么不用定时删除策略？

**定时删除，**用一个定时器来负责监视Key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除Key，因此没有采用这一策略。

定期删除+惰性删除是如何工作的呢？

**定期删除，**Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。

于是，惰性删除派上用场。也就是说在你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么？

不是的，如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。

在Redis.conf中有一行配置：

# maxmemory-policy volatile-lru

该配置就是配内存淘汰策略的：

**Noeviction：**当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；

**Allkeys-lru：**当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的Key。推荐使用，目前项目在用这种；

**Allkeys-random：**当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；

**Volatile-lru：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；

**Volatile-random：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个Key。依然不推荐；

**Volatile-ttl：**当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。

PS：如果没有设置Expire的Key，不满足先决条件（Prerequisites）；那么Volatile-lru、Volatile-random和Volatile-ttl策略的行为，和Noeviction（不删除）基本上一致。

### 六、Redis和数据库双写一致性问题

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题，想要回答这个问题，就要先明白一个前提：如果对数据有强一致性要求，就不能放缓存。我们所做的一切，只能保证最终一致性。

另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据不能放缓存。

给出了详细的分析，在这里简单地说一说：首先，采取正确更新策略，先更新数据库，再删缓存；其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

### 七、应对缓存穿透和缓存雪崩问题

关于“如何应对缓存穿透和缓存雪崩”这两个问题，说句实在话，一般中小型传统软件企业很难碰到。如果有大并发的项目，流量有几百万左右，这两个问题一定要深刻考虑：

**1、应对缓存穿透**

缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

解决方案：

利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库，没得到锁，则休眠一段时间重试；

1、采用异步更新策略，无论Key是否取到值，都直接返回。Value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存，需要做缓存预热（项目启动前，先加载缓存）操作；

2、提供一个能迅速判断请求是否有效的拦截机制，比如利用布隆过滤器，内部维护一系列合法有效的Key，迅速判断出，请求所携带的Key是否合法有效，如果不合法，则直接返回。

2、应对缓存雪崩

缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

解决方案：

1、给缓存的失效时间加上一个随机值，避免集体失效；

2、使用互斥锁，但是该方案吞吐量明显下降了；

3、双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间，自己做缓存预热操作。

然后细分以下几个小点：

a. 从缓存A读数据库，有则直接返回；

b. A 没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程；

c. 更新线程同时更新缓存A和缓存B。

### 八、如何解决Redis并发竞争Key问题

这个问题大致就是同时有多个子系统去Set一个Key。这个时候要注意什么呢？本人提前百度了一下，发现大家思考的答案基本都是推荐用Redis事务机制。但本人不推荐使用Redis的事务机制。因为我们的生产环境，基本都是Redis集群环境，做了数据分片操作。你一个事务中有涉及到多个Key操作的时候，这多个Key不一定都存储在同一个Redis-Server上。因此，Redis的事务机制，十分鸡肋。

解决方法如下：

如果对这个Key操作不要求顺序

这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做Set操作即可，比较简单。

如果对这个Key操作要求顺序

假设有一个Key1，系统A需要将Key1设置为ValueA，系统B需要将Key1设置为ValueB，系统C需要将Key1设置为ValueC。期望按照Key1的Value值按照 ValueA→ValueB→ValueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下：

1、系统A Key 1 {ValueA  3:00}

2、系统B Key 1 {ValueB  3:05}

3、系统C Key 1 {ValueC  3:10}

那么，假设这会系统B先抢到锁，将Key1设置为{ValueB 3:05}。接下来系统A抢到锁，发现自己的ValueA的时间戳早于缓存中的时间戳，那就不做Set操作了。以此类推。

其他方法，比如利用队列，将Set方法变成串行访问也可以。总之，灵活变通。

**1.在你知道必要之前不要优化**

这可能是最重要的性能调整技巧之一。你应该遵循常见的最佳实践做法并尝试高效地实现用例。但是，这并不意味着在你证明必要之前，你应该更换任何标准库或构建复杂的优化。

在大多数情况下，过早优化不但会占用大量时间，而且会使代码变得难以阅读和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费大量时间来优化的是应用程序的非关键部分。

那么，你如何证明你需要优化一些东西呢？

首先，你需要定义应用程序代码的速度得多快，例如，为所有API调用指定最大响应时间，或者指定在特定时间范围内要导入的记录数量。在完成这些之后，你就可以测量应用程序的哪些部分太慢需要改进。然后，接着看第二个技巧。

**2.使用分析器查找真正的瓶颈**

在你遵循第一个建议并确定了应用程序的某些部分需要改进后，那么从哪里开始呢？

你可以用两种方法来解决问题：

- 查看你的代码，并从看起来可疑或者你觉得可能会产生问题的部分开始。
- 或者使用分析器并获取有关代码每个部分的行为和性能的详细信息。

希望不需要我解释为什么应该始终遵循第二种方法的原因。

很明显，基于分析器的方法可以让你更好地理解代码的性能影响，并使你能够专注于最关键的部分。如果你曾使用过分析器，那么你一定记得曾经你是多么惊讶于一下就找到了代码的哪些部分产生了性能问题。老实说，我第一次的猜测不止一次地导致我走错了方向。

**3.为整个应用程序创建性能测试套件**

这是另一个通用技巧，可以帮助你避免在将性能改进部署到生产后经常会发生的许多意外问题。你应该总是定义一个测试整个应用程序的性能测试套件，并在性能改进之前和之后运行它。

这些额外的测试运行将帮助你识别更改的功能和性能副作用，并确保不会导致弊大于利的更新。如果你工作于被应用程序若干不同部分使用的组件，如数据库或缓存，那么这一点就尤其重要。

**4.首先处理最大的瓶颈**

在创建测试套件并使用分析器分析应用程序之后，你可以列出一系列需要解决以提高性能的问题。这很好，但它仍然不能回答你应该从哪里开始的问题。你可以专注于速效方案，或从最重要的问题开始。这个你也必须会。

速效方案一开始可能会很有吸引力，因为你可以很快显示第一个成果。但有时，可能需要你说服其他团队成员或管理层认为性能分析是值得的——因为暂时看不到效果。

但总的来说，我建议首先处理最重要的性能问题。这将为你提供最大的性能改进，而且可能再也不需要去解决其中一些为了满足性能需求的问题。

常见的性能调整技巧到此结束。下面让我们仔细看看一些特定于Java的技巧。

工作一到五年的 Java 的工程师朋友们加入 Java 架构开发群：614478470
 就可以马上免费获得这套内部教材！ [点击加入](https://links.jianshu.com/go?to=https%3A%2F%2Fjq.qq.com%2F%3F_wv%3D1027%26k%3D5gMDouY)

**5.使用StringBuilder以编程方式连接String**

有很多不同的选项来连接Java中的String。例如，你可以使用简单的+或+ =，以及StringBuffer或StringBuilder。

那么，你应该选择哪种方法？

答案取决于连接String的代码。如果你是以编程方式添加新内容到String中，例如在for循环中，那么你应该使用StringBuilder。它很容易使用，并提供比StringBuffer更好的性能。但请记住，与StringBuffer相比，StringBuilder不是线程安全的，可能不适合所有用例。这个你必须清楚。

你只需要实例化一个新的StringBuilder并调用append方法来向String中添加一个新的部分。在你添加了所有的部分之后，你就可以调用toString()方法来检索连接的String。

下面的代码片段显示了一个简单的例子。在每次迭代期间，这个循环将i转换为一个String，并将它与一个空格一起添加到StringBuilder sb中。所以，最后，这段代码将在日志文件中写入“This is a test0 1 2 3 4 5 6 7 8 9”。



```go
StringBuilder sb = new StringBuilder(“This is a test”);
for (int i=0; i<10; i++) {
sb.append(i);
sb.append(” “);
}
log.info(sb.toString());
```

正如在代码片段中看到的那样，你可以将String的第一个元素提供给构造方法。这将创建一个新的StringBuilder，新的StringBuilder包含提供的String和16个额外字符的容量。当你向StringBuilder添加更多字符时，JVM将动态增加StringBuilder的大小。

如果你已经知道你的String将包含多少个字符，则可以将该数字提供给不同的构造方法以实例化具有定义容量的StringBuilder。这进一步提高了效率，因为它不需要动态扩展其容量。

**6.使用+连接一个语句中的String**

当你用Java实现你的第一个应用程序时，可能有人告诉过你不应该用+来连接String。如果你是在应用程序逻辑中连接字符串，这是正确的。字符串是不可变的，每个字符串的连接结果都存储在一个新的String对象中。这需要额外的内存，会减慢你的应用程序，特别是如果你在一个循环内连接多个字符串的话。

在这些情况下，你应该遵循技巧5并使用StringBuilder。

但是，如果你只是将字符串分成多行来改善代码的可读性，那情况就不一样了。



```objectivec
Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ”
+ “FROM Author a ”
+ “WHERE a.id = :id”);
```

在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器会对此优化并在编译时执行连接。所以，在运行时，你的代码将只使用1个String，不需要连接。

**7.尽可能使用基元**

避免任何开销并提高应用程序性能的另一个简便而快速的方法是使用基本类型而不是其包装类。所以，最好使用int来代替Integer，使用double来代替Double。这允许JVM将值存储在堆栈而不是堆中以减少内存消耗，并作出更有效的处理。

**8.试着避免BigInteger和BigDecimal**

既然我们在讨论数据类型，那么我们也快速浏览一下BigInteger和BigDecimal吧。尤其是后者因其精确性而受到大家的欢迎。但是这是有代价的。

BigInteger和BigDecimal比简单的long或double需要更多的内存，并且会显著减慢所有计算。所以，你如果需要额外的精度，或者数字将超过long的范围，那么最好三思而后行。这可能是你需要更改以解决性能问题的唯一方法，特别是在实现数学算法的时候。这个你了解下。

**9.首先检查当前日志级别**

这个建议应该是显而易见的，但不幸的是，很多程序员在写代码的时候都会大多会忽略它。在你创建调试消息之前，始终应该首先检查当前日志级别。否则，你可能会创建一个之后会被忽略的日志消息字符串。

这里有两个反面例子。



```dart
// don’t do this
log.debug(“User [” + userName + “] called method X with [” + i + “]”);

// or this
log.debug(String.format(“User [%s] called method X with [%d]”, userName, i));
```

在上面两种情况中，你都将执行创建日志消息所有必需的步骤，在不知道日志框架是否将使用日志消息的前提下。因此在创建调试消息之前，最好先检查当前的日志级别。



```cpp
// do this
if (log.isDebugEnabled()) { 
  log.debug(“User [” + userName + “] called method X with [” + i + “]”);
}
```

**10.使用Apache Commons StringUtils.Replace而不是String.replace**

一般来说，String.replace方法工作正常，效率很高，尤其是在使用Java 9的情况下。但是，如果你的应用程序需要大量的替换操作，并且没有更新到最新的Java版本，那么我们依然有必要查找更快和更有效的替代品。

有一个备选答案是Apache Commons Lang的StringUtils.replace方法。正如Lukas Eder在他最近的一篇博客文章中所描述的，StringUtils.replace方法远胜Java 8的String.replace方法。

而且它只需要很小的改动。即添加Apache Commons Lang项目的Maven依赖项到应用程序pom.xml中，并将String.replace方法的所有调用替换为StringUtils.replace方法。



```bash
// replace this
test.replace(“test”, “simple test”);

// with this
StringUtils.replace(test, “test”, “simple test”);
```

**11.缓存昂贵的资源，如数据库连接**

缓存是避免重复执行昂贵或常用代码片段的流行解决方案。总的思路很简单：重复使用这些资源比反复创建新的资源要便宜。

一个典型的例子是缓存池中的数据库连接。新连接的创建需要时间，如果你重用现有连接，则可以避免这种情况。

你还可以在Java语言本身找到其他例子。例如，Integer类的valueOf方法缓存了-128到127之间的值。你可能会说创建一个新的Integer并不是太昂贵，但是由于它经常被使用，以至于缓存最常用的值也可以提供性能优势。

但是，当你考虑缓存时，请记住缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此你可能需要管理缓存以使资源可访问，以及删除过时的资源。

所以，在开始缓存任何资源之前，请确保实施缓存是值得的，也就是说必须足够多地使用它们

