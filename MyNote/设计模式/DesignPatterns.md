# 1 GoF设计模式

## 1.1 什么是设计模式

一般而言，一个设计模式有四个基本要素：

1. 模式名称：一个助记名，它用一两各词汇来描述模式的问题、解决方案和效果。
2. 问题：描述了应该在何时使用模式。
3. 解决方案：描述了设计的组成成分，他们之间的相互关系及各自的职责和协作方式。
4. 效果：描述了模式应用的效果及使用模式应权衡的问题。应该包含他对系统的灵活性、扩充性或可移植性的影响。

## 1.2 描述设计模式

使用统一的格式描述设计模式，每一个模式根据以下的模板被分成若干部分：

- 模式名和分类：模式名简洁的描述了模式的本质。
- 意图：是回答下列问题的简单陈述：设计模式是做什么的？他的基本原理和意图是什么？它解决的是什么样的特定设计问题？
- 别名：模式的其他名称
- 动机：用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情境。
- 适用性：什么情况下可以使用该设计模式？该模式可用来改进哪些不良设计？你怎样识别这些情况？
- 结构：采用基于对象建模技术的表示法对模式中的类进行图形描述。我们也使用了交互图来说明对象之间的请求序列和协作关系。
- 参与者：指设计模式中的类和对象以及他们各自的职责。
- 协作：模式的参与者怎样协作以实现他们的职责。
- 效果：模式怎样支持它的目标？使用模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？
- 实现：实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于实现语言的问题。
- 代码示例：原书使用Smalltalk和C++实现，这里应该使用Java来实现。
- 已知应用：实际系统中发现的模式的例子。
- 相关模式：与这个模式紧密相关的模式有哪些？其间重要的不同之处时什么？这个模式应与哪些其他模式一起使用？

## 1.3 设计模式的编目

1. Abstract Factory：提供一个创建一系类相关或相互依赖对象的接口，而无需指定他们具体的类。
2. Adapter：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
3. Bridge：将抽象部分与它的实现部分分离，使他们都可以独立的变化。
4. Builder：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。
5. Chain of Responsibility：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
6. Command：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
7. Composite：将对象组合成属性结构表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。
8. Decorator：动态的给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。
9. Facade：为子系统中的一组接口提供一个一致的姐买你，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
10. Factory Method：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
11. Flyweight：运用共享技术有效的支持大量细粒度的对象。
12. Interpreter：给定一个语言，定义它的文法的一种表示，并定义各解释器，该解释器使用该表示来解释语言中的句子。
13. Iterator：提供一中方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
14. Mediator：用一个中介对象来封装一系类的对象交互。中介者使个对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的该百年他们之间的交互。
15. Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存的状态。
16. Observer：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
17. Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
18. Proxy：为其他对象提供一个代理一控制对这个对象的访问。
19. Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
20. State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了他所属的类。
21. Strategy：定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可独立与使用他的客户。
22. Template Method：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算得结构即可重定义该算法的某些特定步骤。
23. Visitor：表示一个作用于某对象结构中的各元素的操作。他使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 1.4 组织编目

![1571311916013](picture\1571311916013.png)

我们根据两条准则对模式进行分类。第一是**目的准则**，即模式是用来完成什么工作的。模式依据其目的可分为**创建型**、**结构型**和**行为型**三种。创建模型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。

第二是**范围准则**，指定模式主要是用于类还是用于对象。**类模式**处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。**对象模式**处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。

![1571312915223](picture\1571312915223.png)

## 1.5 设计模式怎样解决设计问题

![1571313370048](picture\1571313370048.png)



## 1.1 创建模式

### 1.1.1 Factory（工厂方法）

使用工厂模式就像使用new一样频繁

**定义：**提供创建对象的接口

抽象工厂模式只要更换实现的工厂就可以轻松实现系统功能的巨大变化。

### 1.1.2 Prototype（原型）

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

Prototype模式允许一个对象再创建另一个可定制的对象，根本无需知道任何创建的细节，工作原理是：通过将一个原型对象传给那个要发动创建的兑现给，这个要发动创建的对象通过请求原型对象拷贝他们自己来实现创建。

Java中提供clone()方法来实现对象的克隆。

### 1.1.3 Builder（建筑者）

将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的标表示。

Builder模式是一步一步创建一个复杂的对象，它允许用户可以只通过指定复杂对象的类型和内容就可以构建他们。用户不知道内部的具体构建细节。Builder模式是非常类似抽象工厂模式。

**目的：**将构建复杂的对象的**过程**和他的部件**解耦**。因为一个复杂的对象，不但有很多大量组成部分，如汽车，有很多部件：车轮，方向盘，发动机还有各种小零件等等，但远不止这些，如何将这些部件装配成一辆汽车，这个装配过程也很复杂，Builder模式就是为了将部件和组装过程分开。

### 1.1.4 Singleton（单态）

保证一个类只有一个实例，并提供一个访问它的全局访问点

定义：Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。

有时在某些情况下，使用单态并不能达到单态的目的，如有多个单态对象同时被不同的类装入器装载；在EJB这样的分布式系统中使用也要注意这种情况，因为EJB是跨服务器，跨JVM的。

## 1.2 结构模式

### 1.2.1 Facade（外观）

可扩展的使用JDBC针对不同的数据库编程，Facade提供一中灵活的实现

定义：为子系统中的一组接口提供一个一致的界面

### 1.2.2 Proxy（代理）

代理概念可以解释为：在出发点到目的地之间有一道中间层，意为代理。

定义：为其他对象提供一种代理以控制对这个对象的访问

### 1.2.3 Adapter（适配器）

定义：将两个不兼容的类纠合在一起使用，属于结构模式，需要有Adaptee（被适配者）和Adapter（适配器）两个身份。

### 1.2.4  Composite（合成物）

就是将类用属性结构组合成一个单位。

定义：将对象以树形结构组织起来，以达成“部分-一体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。

### 1.2.5 Decorator（油漆工）

动态给一个对象添加一些额外的职责，就行在墙上刷油漆。使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。

### 1.2.6 Bridge（桥）

定义：将抽象和行为划分开来，各自独立，但能动态的结合。

### 1.2.7 Flyweight（轻量级）

提供Java运行性能，降低小而大两重复的类的开销。

定义：避免大量有用相同内容的小类的开销（如耗费内存），使大家共享一个类（元类）。

## 1.3 行为模式

