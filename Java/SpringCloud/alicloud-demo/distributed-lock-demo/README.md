使用jedis作为链接池

基于redis实现的Java分布式锁主要依赖redis的SETNX命令和DEL命令，SETNX相当于上锁(lock)，DEL相当于释放锁（unlock）。我们只要实现Lock接口重写lock()和unlock()即可。但是这还不够，安全可靠的分布式锁应该满足满足下面三个条件：

l 互斥，不管任何时候，只有一个客户端能持有同一个锁。

l 不会死锁，最终一定会得到锁，即使持有锁的客户端对应的master节点宕掉。

l 容错，只要大多数Redis节点正常工作，客户端应该都能获取和释放锁。

那么什么情况下回不满足上面三个条件呢。多个线程（客户端）同时竞争锁可能会导致多个客户端同时拥有锁。比如，

（1）线程1在master节点拿到了锁（存入key）

（2）master节点在把线程1创建的key写入slave之前宕机了，此时集群中的节点已经没有锁（key）了，包括master节点的slaver节点

（3）slaver节点升级为master节点

（4）线程2向新的master节点发起锁（存入key）请求，很明显，能请求成功。

可见，线程1和线程2同时获得了锁。如果在更高并发的情况，可能会有更多线程（客户端）获取锁，这种情况就会导致上文所说的线程“打架”问题，线程之间的执行杂乱无章。

 

那什么情况下又会发生死锁的情况呢。如果拥有锁的线程（客户端）长时间的执行或者因为某种原因造成阻塞，就会导致锁无法释放（unlock没有调用），其它线程就不能获取锁而而产生无限期死锁的情况。其它线程在执行lock失败后即使粗暴的执行unlock删除key之后也不能正常释放锁，因为锁就只能由获得锁的线程释放，锁不能正常释放其它线程仍然获取不到锁。解决死锁的最好方式是设置锁的有效时间（redis的expire命令），不管是什么原因导致的死锁，有效时间过后，锁将会被自动释放。

 

为了保障容错功能，即只要有Redis节点正常工作，客户端应该都能获取和释放锁，我们必须用相同的key不断循环向Master节点请求锁，当请求时间超过设定的超时时间则放弃请求锁，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，应该尽快尝试下一个master节点。释放锁比较简单，因为只需要在所有节点都释放锁就行，不管之前有没有在该节点获取锁成功。