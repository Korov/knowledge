开展高效有序的重构，关键的心得是：小的步子可以更快前进，请保持代码永远处于可工作状态，小步修改累积起来也能大大改善系统的设计。

傻瓜都能写出计算机可以理解的代码，唯有能写出人类容易理解的代码才是优秀的程序员。

好代码的检验标准就是人们是否能轻而易举地修改它。

# 示例

> 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加特性。

代码：根据输入的json文字进行计算并输出结果

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `Statement for ${invoice.customer}\n`;
    const format = new Intl.NumberFormat("en-US",
        {
            style: "currency", currency: "USD",
            minimumFractionDigits: 2
        }).format;
    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;
        switch (play.type) {
            case "tragedy":
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case "comedy":
                thisAmount = 30000;
                if (perf.audience > 20) {
                    thisAmount += 10000 + 500 * (perf.audience - 20);
                }
                thisAmount += 300 * perf.audience;
                break;
            default:
                throw new Error(`unknown type: ${play.type}`);
        }
        // add volume credits
        volumeCredits += Math.max(perf.audience - 30, 0);
        // add extra credit for every ten comedy attendees
        if ("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);
        // print line for this order
        result += ` ${play.name}: ${format(thisAmount / 100)} (${perf.audience} seats)\n`;
        totalAmount += thisAmount;
    }
    result += `Amount owed is ${format(totalAmount / 100)}\n`;
    result += `You earned ${volumeCredits} credits\n`;
    return result;
}
```

## 测试

重构前必须有一套可靠的测试集，这些测试必须有自我检验能力。

进行重构时，我需要依赖测试，我将测试视为bug检测器，他们能保护我不被自己犯的错误所困扰。

## 分解statement函数

每当看到这样长长的函数，我便下意识地想从整个函数中分离出不同的关注点。第一个引起我注意的就是中间那段switch语句。

我们可以将switch代码段提炼出来，提炼的时候我们需要注意有哪些变量会离开原本的作用域，并给函数起一个好理解的名字，规范的名字应该看到名字就知道函数的作用，需要的话要将这些变量变为参数传递进来。此外要注意那些会被修改的变量，可以的话将其变为函数的返回值。

修改后的代码：函数名为amountFor为某某计算费用，result为计算结果，

```js
function amountFor(perf, play) {
    let result = 0;
    switch (play.type) {
        case "tragedy":
            result = 40000;
            if (perf.audience > 30) {
                result += 1000 * (perf.audience - 30);
            }
            break;
        case "comedy":
            result = 30000;
            if (perf.audience > 20) {
                result += 10000 + 500 * (perf.audience - 20);
            }
            result += 300 * perf.audience;
            break;
        default:
            throw new Error(`unknown type: ${play.type}`);
    }
    return result;
}
```

做完修改后需要执行一遍测试查看测试结果是否正确。

## 移除play变量

观察amountFor函数时，我会看看它的参数都从哪里来。aPerformance是从循环变量中来，所以自然每次循环都会改变，但play变量是由performance变量计算得到的，因此根本没必要将它作为参数传入，我可以在amountFor函数中重新计算得到它。当我分解一个长函数时，我喜欢将play这样的变量移除掉，因为它们创建了很多具有局部作用域的临时变量，这会使提炼函数更加复杂。这里我要使用的重构手法是以查询取代临时变量。

```javascript
function amountFor(aPerformance) {
    let result = 0;
    switch (playFor(aPerformance).type) {
        case "tragedy":
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case "comedy":
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result += 300 * aPerformance.audience;
            break;
        default:
            throw new Error(`unknown type: ${playFor(aPerformance).type}`);
    }
    return result;
}
```

这次重构可能在一些程序员心中敲响警钟：重构前，查找play变量的代码在每次循环中只执行了1次，而重构后却执行了3次。我会在后面探讨重构与性能之间的关系，但现在，我认为这次改动还不太可能对性能有严重影响，即便真的有所影响，后续再对一段结构良好的代码进行性能调优，也容易得多。

移除局部变量的好处就是做提炼时会简单得多，因为需要操心的局部作用域变少了。实际上，在做任何提炼前，我一般都会先移除局部变量。

顶层作用域

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `Statement for ${invoice.customer}\n`;
    const format = new Intl.NumberFormat("en-US",
        {
            style: "currency", currency: "USD",
            minimumFractionDigits: 2
        }).format;
    for (let perf of invoice.performances) {
        // add volume credits
        volumeCredits += Math.max(perf.audience - 30, 0);
        // add extra credit for every ten comedy attendees
        if ("comedy" === playFor(perf).type) volumeCredits += Math.floor(perf.audience / 5);
        // print line for this order
        result += ` ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience} seats)\n`;
        totalAmount += amountFor(perf);
    }
    result += `Amount owed is ${format(totalAmount / 100)}\n`;
    result += `You earned ${volumeCredits} credits\n`;
    return result;
}
```

继续处理临时变量，将format（成为usd函数）和volumeCredits处理一下整理成函数

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = `Statement for ${invoice.customer}\n`;
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
        // print line for this order
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\n`;
        totalAmount += amountFor(perf);
    }
    result += `Amount owed is ${usd(totalAmount)}\n`;
    result += `You earned ${volumeCredits} credits\n`;
    return result;
}
```

## 移除观众量积分总和

我的下一个重构目标是volumeCredits。处理这个变量更加微妙，因为它是在循环的迭代过程中累加得到的。第一步，就是应用拆分循环（227）将volumeCredits的累加过程分离出来。

```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = `Statement for ${invoice.customer}\n`;
    for (let perf of invoice.performances) {
        // print line for this order
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\n`;
        totalAmount += amountFor(perf);
    }
    result += `Amount owed is ${usd(totalAmount)}\n`;
    // 将观众量积分总合移除
    result += `You earned ${totalVolumeCredits()} credits\n`;
    return result;
}

function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) {
        volumeCredits += volumeCreditsFor(perf);
    }
    return volumeCredits;
}
```

这次重构可能在一些程序员心中敲响警钟：重构前，查找play变量的代码在每次循环中只执行了1次，而重构后却执行了3次。我会在后面探讨重构与性能之间的关系，但现在，我认为这次改动还不太可能对性能有严重影响，即便真的有所影响，后续再对一段结构良好的代码进行性能调优，也容易得多。重构至此，让我先暂停一下，谈谈刚刚完成的修改。首先，我知道有些读者会再次对此修改可能带来的性能问题感到担忧，我知道很多人本能地警惕重复的循环。但大多数时候，重复一次这样的循环对性能的影响都可忽略不计。如果你在重构前后进行计时，很可能甚至都注意不到运行速度的变化——通常也确实没什么变化。许多程序员对代码实际的运行路径都所知不足，甚至经验丰富的程序员有时也未能避免。在聪明的编译器、现代的缓存技术面前，我们很多直觉都是不准确的。软件的性能通常只与代码的一小部分相关，改变其他的部分往往对总体性能贡献甚微。

当然，“大多数时候”不等同于“所有时候”。有时，一些重构手法也会显著地影响性能。但即便如此，我通常也不去管它，继续重构，因为有了一份结构良好的代码，回头调优其性能也容易得多。如果我在重构时引入了明显的性能损耗，我后面会花时间进行性能调优。进行调优时，可能会回退我早先做的一些重构——但更多时候，因为重构我可以使用更高效的调优方案。最后我得到的是既整洁又高效的代码。

因此对于重构过程的性能问题，我总体的建议是：大多数情况下可以忽略它。如果重构引入了性能损耗，先完成重构，再做性能优化。

## 继续拆分

```javascript
function statement(invoice, plays) {
    let result = `Statement for ${invoice.customer}\n`;
    for (let perf of invoice.performances) {
        result += ` ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience} seats)\n`;
    }
    result += `Amount owed is ${usd(totalAmount())}\n`;
    result += `You earned ${totalVolumeCredits()} credits\n`;
    return result;
}
function totalAmount() {
    let result = 0;
    for (let perf of invoice.performances) {
        result += amountFor(perf);
    }
    return result;
}
function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
        result += volumeCreditsFor(perf);
    }
    return result;
}
function usd(aNumber) {
    return new Intl.NumberFormat("en-US",
        {
            style: "currency", currency: "USD",
            minimumFractionDigits: 2
        }).format(aNumber / 100);
}
function volumeCreditsFor(aPerformance) {
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === playFor(aPerformance).type) result += Math.floor(aPerformance.audience /
        5);
    return result;
}
function playFor(aPerformance) {
    return plays[aPerformance.playID];
}
function amountFor(aPerformance) {
    let result = 0;
    switch (playFor(aPerformance).type) {
        case "tragedy":
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case "comedy":
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result += 300 * aPerformance.audience;
            break;
        default:
            throw new Error(`unknown type: ${playFor(aPerformance).type}`);
    }
    return result;
}
```

现在代码结构已经好多了。顶层的statement函数现在只剩7行代码，而且它处理的都是与打印详单相关的逻辑。与计算相关的逻辑从主函数中被移走，改由一组函数来支持。每个单独的计算过程和详单的整体结构，都因此变得更易理解了。

## 拆分计算阶段与格式化阶段

到目前为止，我的重构主要是为原函数添加足够的结构，以便我能更好地理解它，看清它的逻辑结构。这也是重构早期的一般步骤。把复杂的代码块分解为更小的单元，与好的命名一样都很重要。现在，我可以更多关注我要修改的功能部分了，也就是为这张详单提供一个HTML版本。不管怎么说，现在改起来更加简单了。因为计算代码已经被分离出来，我只需要为顶部的7行代码实现一个HTML的版本。问题是，这些分解出来的函数嵌套在打印文本详单的函数中。无论嵌套函数组织得多么良好，我总不想将它们全复制粘贴到另一个新函数中。我希望同样的计算函数可以被文本版详单和HTML版详单共用。

要实现复用有许多种方法，而我最喜欢的技术是拆分阶段（154）。这里我的目标是将逻辑分成两部分：一部分计算详单所需的数据，另一部分将数据渲染成文本或HTML。第一阶段会创建一个中转数据结构，再把它传递给第二阶段。

```javascript
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}
function createStatementData(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    statementData.totalAmount = totalAmount(statementData);
    statementData.totalVolumeCredits = totalVolumeCredits(statementData);
    return statementData;
}
```

改变之后的函数，renderPlainText打印数据，createStatementData将数据封装好，这样renderPlainText就只需要打印就行。

## 分离到两个文件（和两个阶段）

statement.js

```javascript
import createStatementData from './createStatementData.js';
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}
function renderPlainText(data, plays) {
    let result = `Statement for ${data.customer}\n`;
    for (let perf of data.performances) {
        result += ` ${perf.play.name}: ${usd(perf.amount)} (${perf.audience} seats)\n`;
    }
    result += `Amount owed is ${usd(data.totalAmount)}\n`;
    result += `You earned ${data.totalVolumeCredits} credits\n`;
    return result;
}
function htmlStatement(
    invoice, plays) {
    return renderHtml(createStatementData(invoice, plays));
}
function renderHtml(
    data) {
    let result = `<h1>Statement for ${data.customer}</h1>\n`;
    result += "<table>\n";
    result += "<tr><th>play</th><th>seats</th><th>cost</th></tr>";
    for (let perf of data.performances) {
        result += ` <tr><td>${perf.play.name}</td><td>${perf.audience}</td>`;
        result += `<td>${usd(perf.amount)}</td></tr>\n`;
    }
    result += "</table>\n";
    result += `<p>Amount owed is <em>${usd(data.totalAmount)}</em></p>\n`;
    result += `<p>You earned <em>${data.totalVolumeCredits}</em> credits</p>\n`;
    return result;
}
function usd(aNumber) {
    return new Intl.NumberFormat("en-US",
        {
            style: "currency", currency: "USD",
            minimumFractionDigits: 2
        }).format(aNumber / 100);
}
```

createStatementData.js

```javascript
export default function createStatementData(invoice, plays) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(result);
    result.totalVolumeCredits = totalVolumeCredits(result);
    return result;
}
function enrichPerformance(aPerformance) {
    const result = Object.assign({}, aPerformance);
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCreditsFor(result);
    return result;
}
function playFor(aPerformance) {
    return plays[aPerformance.playID]
}
function amountFor(aPerformance) {
    let result = 0;
    switch (aPerformance.play.type) {
        case "tragedy":
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case "comedy":
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result += 300 * aPerformance.audience;
            break;
        default:
            throw new Error(`unknown type: ${aPerformance.play.type}`);
    }
    return result;
}
function volumeCreditsFor(aPerformance) {
    let result = 0;
    result += Math.max(aPerformance.audience - 30, 0);
    if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
    return result;
}
function totalAmount(data) {
    return data.performances
        .reduce((total, p) => total + p.amount, 0);
}
function totalVolumeCredits(data) {
    return data.performances
        .reduce((total, p) => total + p.volumeCredits, 0);
}
```

### 按类型重组计算过程

接下来我将注意力集中到下一个特性改动：支持更多类型的戏剧，以及支持它们各自的价格计算和观众量积分计算。对于现在的结构，我只需要在计算函数里添加分支逻辑即可。amountFor函数清楚地体现了，戏剧类型在计算分支的选择上起着关键的作用——但这样的分支逻辑很容易随代码堆积而腐坏，除非编程语言提供了更基础的编程语言元素来防止代码堆积。

要为程序引入结构、显式地表达出“计算逻辑的差异是由类型代码确定”有许多途径，不过最自然的解决办法还是使用面向对象世界里的一个经典特性——类型多态。我的设想是先建立一个继承体系，它有“喜剧”（comedy）和“悲剧”（tragedy）两个子类，子类各自包含独立的计算逻辑。调用者通过调用一个多态的amount函数，让语言帮你分发到不同的子类的计算过程中。volumeCredits函数的处理也是如法炮制。为此我需要用到多种重构方法，其中最核心的一招是以多态取代条件表达式（272），将多个同样的类型码分支用多态取代。但在施展以多态取代条件表达式（272）之前，我得先创建一个基本的继承结构。我需要先创建一个类，并将价格计算函数和观众量积分计算函数放进去。

### 创建演出计算器

enrichPerformance函数是关键所在，因为正是它用每场演出的数据来填充中转数据结构。目前它直接调用了计算价格和观众量积分的函数，我需要创建一个类，通过这个类来调用这些函数。由于这个类存放了与每场演出相关数据的计算函数，于是我把它称为演出计算器（performance calculator）

创建各自的子类在子类中实现计算，而不是在switch中实现计算。

# 重构的原则

重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

## 两顶帽子

使用重构技术开发软件时，我把自己的时间分配给两种截然不同的行为：添加新功能和重构。添加新功能时，我不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常运行，我可以衡量自己的工作进度。重构时我就不能再添加功能，只管调整代码的结构。此时我不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

## 何时重构

三次法则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

### 预备性重构：让添加新功能更容易

重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。也许已经有个函数提供了我需要的大部分功能，但有几个字面量的值与我的需要略有冲突。如果不做重构，我可能会把整个函数复制过来，修改这几个值，但这就会导致重复代码——如果将来我需要做修改，就必须同时修改两处（更麻烦的是，我得先找到这两处）。而且，如果将来我还需要一个类似又略有不同的功能，就只能再复制粘贴一次，这可不是个好主意。所以我戴上重构的帽子，使用函数参数化（310）。做完这件事以后，接下来我就只需要调用这个函数，传入我需要的参数。

### 帮助理解的重构：使代码更易懂

我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。

### 捡垃圾式重构

<u>*这个比喻需要重构的代码就像马路上的垃圾，而重构就是捡垃圾，我们应该养成好习惯，见到小垃圾就处理掉，大垃圾要慢慢处理才行*</u>

帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。

>每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改。

## 何时不应该重构

如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个API之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。

另一种情况是，如果重写比重构还容易，就别重构了。这是个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验，我无法给出一条简单的建议。

## 重构的挑战

想要重构就会做出一定的牺牲。

### 延缓新工能开发

重构的唯一目的就是让我们更快速的开发，用更少的工作量创造更大的价值。

有一种情况：有时候我们会遇到一个很有必要的大规模重构，但是却又一个很小的功能需要添加，通常我们会先添加新功能然后进行重构。

### 代码所有权

很多重构手法不仅会影响模块内部，还会影响该模块与系统其他部分的关系。比如我想给一个函数改名，并且我也能找到该函数的所有调用者，那么我只需运用改变函数声明（124），在一次重构中修改函数声明和调用者。但即便这么简单的一个重构，有时也无法实施：调用方代码可能由另一支团队拥有，而我没有权限写入他们的代码库；这个函数可能是一个提供给客户的API，这时我根本无法知道是否有人使用它，至于谁在用、用得有多频繁就更是一无所知。这样的函数属于已发布接口（published interface）：接口的使用者（客户端）与声明者彼此独立，声明者无权修改使用者的代码。

代码所有权的边界会妨碍重构，因为一旦我自作主张地修改，就一定会破坏使用者的程序。这不会完全阻止重构，我仍然可以做很多重构，但确实会对重构造成约束。为了给一个函数改名，我需要使用函数改名（124），但同时也得保留原来的函数声明，使其把调用传递给新的函数。这会让接口变复杂，但这就是为了避免破坏使用者的系统而不得不付出的代价。我可以把旧的接口标记为“不推荐使用”（deprecated），等一段时间之后最终让其退休；但有些时候，旧的接口必须一直保留下去。

### 分支

很多团队采用这样的版本控制实践：每个团队成员各自在代码库的一条分支上工作，进行相当大量的开发之后，才把各自的修改合并回主线分支，从而与整个团队分享。但是对分支进行集成的时候随着分支开发的时间增长，分支继承的难度会急剧增长。

推荐采用持续集成（CI）的的方式，也叫基于主干开发。这种方式避免了任何分支彼此之间差异太大，从而极大的降低了合并的难度。不过CI也有代价：你必须使用相关的实践以确保主线随时处于健康状态，必须学会将大功能拆分成小块，还必须使用特性开关将尚未完成又无法拆小的功能隐藏。

CI降低了分支合并的难度，但最重要的是CI能够与重构良好配合。但是CI应该与特性分支一起工作，前提是特性分支的存在时间必须足够短，或者分支集成的时间够短。

### 测试

完整可靠的测试可以确保重构之后代码功能的完整性和正确性。但是编写这些测试会需要大量的时间和精力，这会拖延新功能的开发。

### 遗留代码

遗留代码往往很复杂，测试又不足，最关键的是别人写的。

此时重构可以很好的帮助我们理解遗留系统，修改函数名，理顺程序结构，但是没有测试我们很难保证我们的修改不会引起程序功能的破坏。

我们必须自己写测试，可以参考《修改代码的艺术》（找到程序的接缝，在接缝处插入测试，如此将系统至于测试覆盖率之下），有时候你需要使用重构创造出接缝。

### 数据库

渐进式数据库设计和数据库重构，这项技术的精要在于：借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模、涉及数据库的修改可以比较容易的开展。

# 坏代码的味道

## 神秘命名

类名，方法名，变量名这些都是需要仔细考虑决定的，必须能够体现一定的意义，否则命名就是失败的。

## 重复代码

对于重复代码一定要抽取出来。

## 过长函数

函数行数：10行最好，20行左右可以，50行不太行，再多就要分解了。

函数越长越难理解，我们应该更积极的分解函数，分解的规则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途命名。我们可以对一组甚至短短一行代码做这件事。

提炼函数是常用的手段，但是要注意提炼函数的过程中尽量减少传递的参数

条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的switch语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。

至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。

## 过长参数列表

一个最好，两个可以，三个不推荐，再多就封装。

## 全局数据

全局数据是最刺鼻的坏味道之一。代码库中的任何一个角落都可以修改全局数据，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。

首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。

## 可变数据

一个数据被大范围使用，每个使用的地方都可以修改此数据的值，有时候会造成此处功能正常，但是另一处功能出错，最好将数据做了封装，控制更改的权限，或者使用者只能获取此变量的副本。

尤其是传递的参数可能被修改后会出现问题。

## 发散式变化

当你看着一个类说：“呃，如果新加入一个数据库，我必须修改这3个函数；如果新出现一种金融工具，我必须修改这4个函数。”这就是发散式变化的征兆。数据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好：每当要对某个上下文做修改时，我们只需要理解这个上下文，而不必操心另一个。“每次只关心一个上下文”这一点一直很重要。

如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理），就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通。如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数（198）把处理逻辑分开。如果函数内部混合了两类处理逻辑，应该先用提炼函数（106）将其分开，然后再做搬移。如果模块是以类的形式定义的，就可以用提炼类（182）来做拆分。

## 霰弹式修改

霰弹式修改类似于发散式变化，但又恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。

这种情况下，你应该使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换（149）。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）

## 依恋情节

所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。

这时候我们可以将被调用的函数搬移到调用函数中，当依恋多个模块函数的时候，我们应该谨慎只搬取少部分依恋较强的。

## 数据泥团

你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。首先请找出这些数据以字段形式出现的地方，运用提炼类（182）将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身。这么做的直接好处是可以将很多参数列表缩短，简化函数调用。是的，不必在意数据泥团只用上新对象的一部分字段，只要以新对象取代两个（或更多）字段，就值得这么做。

## 基本类型偏执

该创建新对象的时候就创建新对象，不要执迷于基本类型。

你可以运用以对象取代基本类型（174）将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉。

## 重复的switch

单个的，简单的switch是没有问题的，但是当多个地方都使用到相同的switch或者if-elseif判断就应该考虑使用多态来替换switch。因为你每次想增加分支的时候都需要找到所有的switch进行修改。

## 循环语句

java中尽量使用管道来替代循环，例如filter和map。

## 冗余元素

程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。可能有这样一个函数，它的名字就跟实现代码看起来一模一样；也可能有这样一个类，根本就是一个简单的函数。这可能是因为，起初在编写这个函数时，程序员也许期望它将来有一天会变大、变复杂，但那一天从未到来；也可能是因为，这个类原本是有用的，但随着重构的进行越变越小，最后只剩了一个函数。不论上述哪一种原因，请让这样的程序元素庄严赴义吧。通常你只需要使用内联函数（115）或是内联类（186）。如果这个类处于一个继承体系中，可以使用折叠继承体系（380）。

## 夸夸其谈通用性

如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。不必要的委托可运用内联函数（115）和内联类（186）除掉。如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数。如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。

## 临时字段

有时你会看到这样的类：其内部某个字段仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的，会让你发疯。

请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。

## 过长的消息链

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。

这时候应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。

## 中间人

你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。

但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人（192），直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用内联函数（115）把它们放进调用端。如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。

## 内幕交易

软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。

如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数（198）和搬移字段（207）减少它们的私下交流。如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关系（189），把另一个模块变成两者的中介。

继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让这个孩子独立生活了，请运用以委托取代子类（381）或以委托取代超类（399）让它离开继承体系。

## 过大的类

类的行数：200很好，500不错，1000可接受，再多不行了。

你可以运用提炼类（182）将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。

通常，如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。

## 异曲同工的类

请反复运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类（375）补偿一下。

## 纯数据类

所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。

这些类早期可能拥有public字段，若果真如此，你应该在别人注意到它们之前，立刻运用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）。然后，找出这些取值/设值函数被其他类调用的地点。尝试以搬移函数（198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数（106）产生一个可被搬移的函数。

## 被拒绝的遗赠

子类应该继承超类的函数和数据。但如果它们不想或不需要继承，又该怎么办呢？你需要为这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟。这样一来，超类就只持有所有子类共享的东西。

## 注释

当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。

类名，方法名和变量名应该变成注释的一部分，尽量少些多余的注释。

# 构建测试体系

java中推荐使用junit5，使用maven或者gradle自动化测试，并使用jacoco检测测试覆盖率。

# 第一组重构

这里首先介绍最有用的重构。

## 提炼函数

反向重构：内联函数。

浏览一段代码，理解其作用，然后将其提炼到一个独立的函数中，并以这段代码的用途为这个函数命名。

### 动机

如果你需要花时间浏览一段代码才能弄清楚他到底在干什么，那么就应该将其提炼到一个函数中，并根据他所做的事为其命名。

### 做法

- 创建一个函数，根据函数的意图对函数命名
- 将待提炼的代码从源函数复制到新建的目标函数中
- 仔细检查提炼出的代码，看看其中是否引用了作用域限于源函数、在提炼出的新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数。
- 所有变量都处理完之后，编译。
- 在源函数中，将被提炼代码段替换为对目标函数的调用。
- 测试
- 查看其他代码是否有与被提炼的代码段相同或相似之处。如果有，考虑使用以函数调用取代内联代码（222）令其调用提炼出的新函数

## 内联函数

反向重构：提炼函数

![image-20200418191104732](http://korov.myqnapcloud.cn:19000/images/EffectiveJava3.png)

### 动机

本书经常以简短的函数表现动作意图，这样会使代码更清晰易读。但有时候你会遇到某些函数，其内部代码和函数名称同样清晰易读。也可能你重构了该函数的内部实现，使其内容和其名称变得同样清晰。若果真如此，你就应该去掉这个函数，直接使用其中的代码。

另一种需要使用内联函数的情况是：我手上有一群组织不甚合理的函数。可以将它们都内联到一个大型函数中，再以我喜欢的方式重新提炼出小函数。

### 做法

- 检查函数，确定它不具多态性

  > 如果该函数属于一个类，并且有子类继承了这个函数，那么就无法内联

- 找出这个函数的所有调用点

- 将这个函数的所有调用点都替换为函数本体

- 每次替换之后，执行测试。

- 删除该函数的定义。

被我这样一写，内联函数似乎很简单。但情况往往并非如此。对于递归调用、多返回点、内联至另一个对象中而该对象并无访问函数等复杂情况，我可以写上好几页。我之所以不写这些特殊情况，原因很简单：如果你遇到了这样的复杂情况，就不应该使用这个重构手法。

## 提炼变量

反向重构：内联变量

重构前：

```javascript
return order.quantity * order.itemPrice -
　Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +
　Math.min(order.quantity * order.itemPrice * 0.1, 100);
```

重构后：

```javascript
const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;
```

### 动机

表达式有可能非常复杂而难以阅读。这种情况下，局部变量可以帮助我们将表达式分解为比较容易管理的形式。在面对一块复杂逻辑时，局部变量使我能给其中的一部分命名，这样我就能更好地理解这部分逻辑是要干什么。

### 做法

- 确认要提炼的表达式没有副作用。
- 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值。
- 用这个新变量取代原来的表达式
- 测试

## 内联变量

反向重构：提炼变量

重构前：

```javascript
let basePrice = anOrder.basePrice;
return (basePrice > 1000);
```

重构后：

```javascript
return anOrder.basePrice > 1000;
```

### 动机

在一个函数内部，变量能给表达式提供有意义的名字，因此通常变量是好东西。但有时候，这个名字并不比表达式本身更具表现力。还有些时候，变量可能会妨碍重构附近的代码。若果真如此，就应该通过内联的手法消除变量。

### 做法

- 检查确认变量赋值语句的右侧表达式没有副作用
- 如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试
- 找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式
- 测试
- 重复前面两步，逐一替换其他所有使用该变量的地方
- 删除该变量的声明点和赋值语句
- 测试

## 改变函数声明

包括改变函数名称，参数名称，参数数量，参数类型等。

重构前：

```javascript
function circum(radius) {...}
```

重构后：

```javascript
function circumference(radius) {...}
```

### 动机

如果我看到一个函数的名字不对，一旦发现了更好的名字，就得尽快给函数改名。对于函数的参数，道理也是一样。

### 封装变量

重构前：

```javascript
let defaultOwner = {firstName: "Martin", lastName: "Fowler"};
```



```javascript
let defaultOwnerData = {firstName: "Martin", lastName: "Fowler"};
export function defaultOwner() {return defaultOwnerData;}
export function setDefaultOwner(arg) {defaultOwnerData = arg;}
```

### 动机

如果一个数据被大范围使用，此时迁移会很麻烦，最好的办法往往是先以函数形式封装所有对该数据的访问。这样，我就能把“重新组织数据”的困难任务转化为“重新组织函数”这个相对简单的任务。

封装数据的价值还不止于此。封装能提供一个清晰的观测点，可以由此监控数据的变化和使用情况；我还可以轻松地添加数据被修改时的验证或后续逻辑。我的习惯是：对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。处理遗留代码时，一旦需要修改或增加使用可变数据的代码，我就会借机把这份数据封装起来，从而避免继续加重耦合一份已经广泛使用的数据。

### 做法

- 创建封装函数，在其中访问和更新变量值
- 执行静态检查
- 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试。
- 限制变量的可见性
- 测试
- 如果变量的值是一个记录，考虑使用封装记录

### 变量改名

### 引入参数对象

重构前：

```javascript
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}
```

重构后：

```javascript
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

### 动机

我常会看见，一组数据项总是结伴同行，出没于一个又一个函数。这样一组数据就是所谓的数据泥团，我喜欢代之以一个数据结构。

但这项重构真正的意义在于，它会催生代码中更深层次的改变。一旦识别出新的数据结构，我就可以重组程序的行为来使用这些结构。我会创建出函数来捕捉围绕这些数据的共用行为——可能只是一组共用的函数，也可能用一个类把数据结构与使用数据的函数组合起来。这个过程会改变代码的概念图景，将这些数据结构提升为新的抽象概念，可以帮助我更好地理解问题域。果真如此，这个重构过程会产生惊人强大的效用——但如果不用引入参数对象开启这个过程，后面的一切都不会发生。

### 做法

- 如果暂时还没有一个合适的数据结构，就创建一个

  > 我倾向于使用类，因为稍后把行为放进来会比较容易。我通常会尽量确保
  > 这些新建的数据结构是值对象[mf-vo]。

- 测试
- 使用改变函数声明（124）给原来的函数新增一个参数，类型是新建的数据结构。
- 测试
- 调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试
- 用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数。测试。

## 函数组合成类

重构前：

```javascript
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}
```

```javascript
class Reading {
base() {...}
taxableCharge() {...}
calculateBaseCharge() {...}
}
```

### 动机

如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），我就认为，是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用，并且这样一个对象也可以更方便地传递给系统的其他部分。

除了可以把已有的函数组织起来，这个重构还给我们一个机会，去发现其他的计算逻辑，将它们也重构到新的类当中。

### 做法

- 运用封装记录（162）对多个函数共用的数据记录加以封装
- 对于使用该记录结构的每个函数，运用搬移函数（198）将其移入新类
- 用以处理该数据记录的逻辑可以用提炼函数（106）提炼出来，并移入新类

## 函数组合成变换

重构前：

```javascript 
function base(aReading) {...}
function taxableCharge(aReading) {...}
```

重构后：

```javascript
function enrichReading(argReading) {
const aReading = _.cloneDeep(argReading);
aReading.baseCharge = base(aReading);
aReading.taxableCharge = taxableCharge(aReading);
return aReading;
}
```

### 动机

在软件中，经常需要把数据“喂”给一个程序，让它再计算出各种派生信息。这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。

一个方式是采用数据变换（transform）函数：这种函数接受源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。有了变换函数，我就始终只需要到变换函数中去检查计算派生数据的逻辑。

### 做法

- 创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。
- 挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段。
- 测试
- 针对其他相关的计算逻辑，重复上述步骤

## 拆分阶段

重构前：

```javascript
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;	
```

重构后：

```javascript
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);
function parseOrder(aString) {
　const values = aString.split(/\s+/);
　return ({
　　productID: values[0].split("-")[1],
　　quantity: parseInt(values[1]),
　});
} function price(order, priceList) {
　return order.quantity * priceList[order.productID];
}
```

### 动机

每当看见一段代码在同时处理两件不同的事，我就想把它拆分成各自独立的模块，因为这样到了需要修改的时候，我就可以单独处理每个主题，而不必同时在脑子里考虑两个不同的主题。

### 做法

- 将第二阶段的代码提炼成独立的函数
- 测试
- 引入一个中转数据结构，将其作为参数添加到提炼出的新函数的参数列表中
- 测试
- 逐一检查提炼出的“第二阶段函数”的每个参数。如果某个参数被第一阶段用到，就将其移入中转数据结构。每次搬移之后都要执行测试。
- 对第一阶段的代码运用提炼函数（106），让提炼出的函数返回中转数据结构。

# 封装

## 封装记录

```javascript
organization = {name: "Acme Gooseberries", country: "GB"};
```

```javascript
class Organization {
　constructor(data) {
　　this._name = data.name;
　　this._country = data.country;
　}
　get name() {return this._name;}
　set name(arg) {this._name = arg;}
　get country() {return this._country;}
　set country(arg) {this._country = arg;}
}
```

### 动机

记录型结构是多数编程语言提供的一种常见特性。它们能直观地组织起存在关联的数据，让我可以将数据作为有意义的单元传递，而不仅是一堆数据的拼凑。但简单的记录型结构也有缺陷，最恼人的一点是，它强迫我清晰地区分“记录中存储的数据”和“通过计算得到的数据”。

### 做法

- 对持有记录的变量使用封装变量（132），将其封装到一个函数中。
- 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后在类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数，令其使用这个访问函数。
- 测试
- 新建一个函数，让它返回该类的对象，而非那条原始的记录。
- 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。使用对象上的访问函数来获取数据的字段，如果该字段的访问函数还不存在，那就创建一个。每次更改之后运行测试。
- 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。
- 测试
- 如果记录中的字段本身也是复杂结构，考虑对其再次应用封装记录（162）或封装集合（170）手法。

## 封装集合

### 动机

我喜欢封装程序中的所有可变数据。这使我很容易看清楚数据被修改的地点和修改方式，这样当我需要更改数据结构时就非常方便。我们通常鼓励封装——使用面向对象技术的开发者对封装尤为重视——但封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。

### 做法

- 如果集合的引用尚未被封装起来，先用封装变量（132）封装它。
- 在类上添加用于“添加集合元素”和“移除集合元素”的函数。
- 执行静态检查。
- 查找集合的引用点。如果有调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试。
- 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。
- 测试

## 以对象取代基本类型

## 以查询取代临时变量

## 提炼类

### 动机

你也许听过类似这样的建议：一个类应该是一个清晰的抽象，只处理一些明确的责任，等等。但是在实际工作中，类会不断成长扩展。你会在这儿加入一些功能，在那儿加入一些数据。给某个类添加一项新责任时，你会觉得不值得为这项责任分离出一个独立的类。于是，随着责任不断增加，这个类会变得过分复杂。很快，你的类就会变成一团乱麻。

## 内联类

### 动机

内联类正好与提炼类（182）相反。如果一个类不再承担足够责任，不再有单独存在的理由（这通常是因为此前的重构动作移走了这个类的责任），我就会挑选这一“萎缩类”的最频繁用户（也是一个类），以本手法将“萎缩类”塞进另一个类中。

## 隐藏委托关系

重构前：

```javascript
manager = aPerson.department.manager;
```

重构后

```javascript
manager = aPerson.manager;
class Person {
get manager() {return this.department.manager;}
}
```

### 动机

如果某些客户端先通过服务对象的字段得到另一个对象（受托类），然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一受托类修改了接口，变化会波及通过服务对象使用它的所有客户端。我可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。这么一来，即使将来委托关系发生变化，变化也只会影响服务对象，而不会直接波及所有客户端。

### 做法

- 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数
- 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试
- 如果将来不再有任何客户端需要取用Delegate（受托类），便可移除服务对象中的相关访问函数。
- 测试

## 移除中间人

重构前：

```javascript
manager = aPerson.manager;
class Person {
　get manager() {return this.department.manager;}
　}
```

重构后：

```javascript
manager = aPerson.department.manager;
```

### 动机

在隐藏委托关系（189）的“动机”一节中，我谈到了“封装受托对象”的好处。但是这层封装也是有代价的。每当客户端要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性（功能）越来越多，更多的转发函数就会使人烦躁。服务类完全变成了一个中间人（81），此时就应该让客户直接调用受托类。（这个味道通常在人们狂热地遵循迪米特法则时悄然出现。我总觉得，如果这条法则当初叫作“偶尔有用的迪米特建议”，如今能少很多烦恼。）

### 做法

- 为受托对象创建一个取值函数。
- 对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试。

## 替换算法

重构前：

```javascript
function foundPerson(people) {
　for(let i = 0; i < people.length; i++) {
　　if (people[i] === "Don") {
　　　return "Don";
　　}
　　if (people[i] === "John") {
　　　return "John";
　　}
　　if (people[i] === "Kent") {
　　　return "Kent";
　　}
　}
　return "";
}
```

重构后：

```javascript
function foundPerson(people) {
　const candidates = ["Don", "John", "Kent"];
　return people.find(p => candidates.includes(p)) || '';
}
```

### 动机

“重构”可以把一些复杂的东西分解为较简单的小块，但有时你就必须壮士断腕，删掉整个算法，代之以较简单的算法。随着对问题有了更多理解，我往往会发现，在原先的做法之外，有更简单的解决方案，此时我就需要改变原先的算法。如果我开始使用程序库，而其中提供的某些功能/特性与我自己的代码重复，那么我也需要改变原先的算法。

### 做法

- 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中
- 先只为这个函数准备测试，以便固定它的行为。
- 准备好另一个（替换用）算法
- 执行静态检查
- 运行测试，比对新旧算法的运行结果。如果测试通过，那就大功告成；否则，在后续测试和调试过程中，以旧算法为比较参照标准。

# 搬移特性

## 搬移函数

重构前：

```javascript
class Account {
　get overdraftCharge() {...}
```

重构后：

```javascript
class AccountType {
get overdraftCharge() {...}
```

### 动机

搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少。此时，让它去与那些更亲密的元素相会，通常能取得更好的封装效果，因为系统别处就可以减少对当前模块的依赖。

同样，如果我在整理代码时，发现需要频繁调用一个别处的函数，我也会考虑搬移这个函数。有时你在函数内部定义了一个帮助函数，而该帮助函数可能在别的地方也有用处，此时就可以将它搬移到某些更通用的地方。同理，定义在一个类上的函数，可能挪到另一个类中去更方便我们调用。

### 做法

- 检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬移
- 检查待搬移函数是否具备多态性
- 将函数复制一份到目标上下文中。调整函数，使它能适应新家
- 执行静态检查
- 设法从源上下文中正确引用目标函数
- 修改源函数，使之成为一个纯委托函数
- 测试
- 考虑对源函数使用内联函数

## 搬移字段

重构前：

```javascript
class Customer {
get plan() {return this._plan;}
get discountRate() {return this._discountRate;}
```

重构后：

```javascript
class Customer {
get plan() {return this._plan;}
get discountRate() {return this.plan.discountRate;}
```

### 动机

数据结构才是一个健壮程序的根基，但是好的数据结构很难一次作对，如果我发现数据结构已经不适应于需求，就应该马上修缮它。

当我们发现每当调用某个函数时，除了传入一个记录参数，还总是需要同时传入另一条记录的某个字段一起作为参数，总是一同出现、一同作为函数参数传递的数据，最好是规整到同一条记录中，以体现他们之间的联系。

### 做法

- 确保源字段已经得到了良好封装
- 测试
- 在目标对象上创建一个字段（及对应的访问函数）。
- 执行静态检查。
- 确保源对象里能够正常引用目标对象。
- 调整源对象的访问函数，令其使用目标对象的字段。
- 测试
- 移除源对象上的字段

## 搬移语句到函数

重构前：

```javascript
result.push(`<p>title: ${person.photo.title}</p>`);
result.concat(photoData(person.photo));
function photoData(aPhoto) {
　return [
　　`<p>location: ${aPhoto.location}</p>`,
　　`<p>date: ${aPhoto.date.toDateString()}</p>`,
];
}
```

重构后：

```javascript
result.concat(photoData(person.photo));
function photoData(aPhoto) {
　return [
　　`<p>title: ${aPhoto.title}</p>`,
　　`<p>location: ${aPhoto.location}</p>`,
　　`<p>date: ${aPhoto.date.toDateString()}</p>`,
　];
}
```

### 动机

要维护代码库的健康发展，需要遵守几条黄金守则，其中最重要的一条当属“消除重复”。如果我发现调用某个函数时，总有一些相同的代码也需要每次执行，那么我会考虑将此段代码合并到函数里头。这样，日后对这段代码的修改只需改一处地方，还能对所有调用者同时生效。如果将来代码对不同的调用者需有不同的行为，那时再通过搬移语句到调用者（217）将它（或其一部分）搬移出来也十分简单。

如果某些语句与一个函数放在一起更像一个整体，并且更有助于理解，那我就会毫不犹豫地将语句搬移到函数里去。如果它们与函数不像一个整体，但仍应与函数一起执行，那我可以用提炼函数（106）将语句和函数一并提炼出去。这基本就是我下面要描述的做法了，只是下面还多了内联和改名的步骤。这些清理工作通常有其必要性，可以在完成核心步骤后再择机完成。

### 做法

- 如果重复的代码段离调用目标函数的地方还有些距离，则先用移动语句（223）将这些语句挪动到紧邻目标函数的位置。
- 如果目标函数仅被唯一一个源函数调用，那么只需将源函数中的重复代码段剪切并粘贴到目标函数中即可，然后运行测试。本做法的后续步骤至此可以忽略。
- 如果函数不止一个调用点，那么先选择其中一个调用点应用提炼函数（106），将待搬移的语句与目标函数一起提炼成一个新函数。给新函数取个临时的名字，只要易于搜索即可。
- 调整函数的其他调用点，令它们调用新提炼的函数。每次调整之后运行测试。完成所有引用点的替换后，应用内联函数（115）将目标函数内联到新函数里，并移除原目标函数。
- 对新函数应用函数改名（124），将其改名为原目标函数的名字。

## 搬移语句到调用者

重构前：

```javascript
emitPhotoData(outStream, person.photo);
function emitPhotoData(outStream, photo) {
　outStream.write(`<p>title: ${photo.title}</p>\n`);
　outStream.write(`<p>location: ${photo.location}</p>\n`);
}
```

重构后：

```javascript
emitPhotoData(outStream, person.photo);
outStream.write(`<p>location: ${person.photo.location}</p>\n`);
function emitPhotoData(outStream, photo) {
　outStream.write(`<p>title: ${photo.title}</p>\n`);
}
```

## 以函数调用取代内联代码

重构前：

```javascript
let appliesToMass = false;
for(const s of states) {
if (s === "MA") appliesToMass = true;
}
```

重构后：

```javascript
appliesToMass = states.includes("MA");
```

## 移动语句

重构前：

```javascript
const pricingPlan = retrievePricingPlan();
const order = retreiveOrder();
let charge;
const chargePerUnit = pricingPlan.unit;
```

重构后：

```javascript
const pricingPlan = retrievePricingPlan();
const chargePerUnit = pricingPlan.unit;
const order = retreiveOrder();
let charge;
```

## 拆分循环

重构前：

```javascript
let averageAge = 0;
let totalSalary = 0;
for (const p of people) {
　averageAge += p.age;
　totalSalary += p.salary;
} averageAge =
averageAge /
people.length;
```

重构后：

```javascript
let totalSalary = 0;
for (const p of people) {
　totalSalary += p.salary;
}
let averageAge = 0;
for (const p of people) {
　averageAge += p.age;
} averageAge =
averageAge /
people.length;
```

### 动机

你常常能见到一些身兼多职的循环，它们一次做了两三件事情，不为别的，就因为这样可以只循环一次。但如果你在一次循环中做了两件不同的事，那么每当需要修改循环时，你都得同时理解这两件事情。如果能够将循环拆分，让一个循环只做一件事情，那就能确保每次修改时你只需要理解要修改的那块代码的行为就可以了。

拆分循环还能让每个循环更容易使用。如果一个循环只计算一个值，那么它直接返回该值即可；但如果循环做了太多件事，那就只得返回结构型数据或者通过局部变量传值了。因此，一般拆分循环后，我还会紧接着对拆分得到的循环应用提炼函数（106）。

这项重构手法可能让许多程序员感到不安，因为它会迫使你执行两次循环。对此，我一贯的建议也与2.8节里所明确指出的一致：先进行重构，然后再进行性能优化。我得先让代码结构变得清晰，才能做进一步优化；如果重构之后该循环确实成了性能的瓶颈，届时再把拆开的循环合到一起也很容易。但实际情况是，即使处理的列表数据更多一些，循环本身也很少成为性能瓶颈，更何况拆分出循环来通常还使一些更强大的优化手段变得可能。

## 以管道取代循环

重构前：

```javascript
const names = [];
for (const i of input) {
if (i.job === "programmer")
names.push(i.name);
}
```

重构后：

```javascript
const names = input
.filter(i => i.job === "programmer")
.map(i => i.name)
;
```

## 移除死代码

删除没有用的代码，当你尝试阅读代码、理解软件的运作原理时，无用代码确实会带来很多额外的思维负担。它们周围没有任何警示或标记能告诉程序员，让他们能够放心忽略这段函数，因为已经没有任何地方使用它了。当程序员花费了许多时间，尝试理解它的工作原理时，却发现无论怎么修改这段代码都无法得到期望的输出。

# 重新组织数据

## 拆分变量

重构前：

```javascript
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);
```

重构后：

```javascript
const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
```

### 动机

变量有各种不同的用途，其中某些用途会很自然地导致临时变量被多次赋值。如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，每个变量只承担一个责任。同一个变量承担两件不同的事情，会令代码阅读者糊涂。

## 字段改名

重构前：

```javascript
class Organization {
get name() {...}
}
```

重构后：

```javascript
class Organization {
get title() {...}
}
```

## 以查询取代派生变量

重构前：

```javascript
get discountedTotal() {return this._discountedTotal;}
set discount(aNumber) {
　const old = this._discount;
　this._discount = aNumber;
　this._discountedTotal += old - aNumber;
}
```

重构后：

```javascript
get discountedTotal() {return this._baseTotal - this._discount;}
set discount(aNumber) {this._discount = aNumber;}
```

### 动机

可变数据是软件中最大的错误源头之一。对数据的修改常常导致代码的各个部分以丑陋的形式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏。很多时候，完全去掉可变数据并不现实，但我还是强烈建议：尽量把可变数据的作用域限制在最小范围。

有些变量其实可以很容易地随时计算出来。如果能去掉这些变量，也算朝着消除可变性的方向迈出了一大步。计算常能更清晰地表达数据的含义，而且也避免了“源数据修改时忘了更新派生变量”的错误。

## 将引用对象改为值对象

重构前：

```javascript
class Product {
applyDiscount(arg) {this._price.amount -= arg;}
```

重构后：

```javascript
class Product {
applyDiscount(arg) {
this._price = new Money(this._price.amount - arg, this._price.currency);
}
```

### 动机

在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象。两者最明显的差异在于如何更新内部对象的属性：如果将内部对象视为引用对象，在更新其属性时，我会保留原对象不动，更新内部对象的属性；如果将其视为值对象，我就会替换整个内部对象，新换上的对象会有我想要的属性值。

## 将值对象改为引用对象

重构前：

```javascript
let customer = new Customer(customerData);
```

重构后：

```javascript
let customer = customerRepository.get(customerData.id);
```

### 动机

某处修改变量的值之后其他地方也需要可以查看该变量的修改值时应该使用这种方式。

# 简化条件逻辑

## 分解条件表达式

重构前：

```javascript
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
　charge = quantity * plan.summerRate;
else
　charge = quantity * plan.regularRate + plan.regularServiceCharge;
```

重构后：

```javascript
if (summer())
　charge = summerCharge();
else
　charge = regularCharge();
```

### 动机

对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。本重构手法其实只是提炼函数（106）的一个应用场景。但我要特别强调这个场景，因为我发现它经常会带来很大的价值。

## 合并条件表达式

重构前：

```javascript
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled > 12) return 0;
if (anEmployee.isPartTime) return 0;
```

重构后：

```javascript
if (isNotEligibleForDisability()) return 0;
function isNotEligibleForDisability() {
　return ((anEmployee.seniority < 2)
　　　　　|| (anEmployee.monthsDisabled > 12)
　　　　　|| (anEmployee.isPartTime));
}
```

### 动机

有时我会发现这样一串条件检查：检查条件各不相同，最终行为却一致。如果发现这种情况，就应该使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式。

## 以卫语句取代嵌套条件表达式

重构前：

```javascript
function getPayAmount() {
　let result;
　if (isDead)
　　result = deadAmount();
　else {
　　if (isSeparated)
　　　result = separatedAmount();
　　else {
　　　if (isRetired)
　　　　result = retiredAmount();
　　　else
　　　　result = normalPayAmount();
　　}
　}
　return result;
}
```

重构后：

```javascript
function getPayAmount() {
　if (isDead) return deadAmount();
　if (isSeparated) return separatedAmount();
　if (isRetired) return retiredAmount();
　return normalPayAmount();
}
```

### 动机

如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句”（guard clauses）。

## 以多态取代条件表达式

重构前：

```javascript
switch (bird.type) {
　case 'EuropeanSwallow':
　　return "average";
　case 'AfricanSwallow':
　　return (bird.numberOfCoconuts > 2) ? "tired" : "average";
　case 'NorwegianBlueParrot':
　　return (bird.voltage > 100) ? "scorched" : "beautiful";
　default:
　　return "unknown";
```

重构后：

```javascript
class EuropeanSwallow {
　get plumage() {
　　return "average";
　}
class AfricanSwallow {
　get plumage() {
　　 return (this.numberOfCoconuts > 2) ? "tired" : "average";
　}
class NorwegianBlueParrot {
　get plumage() {
　　 return (this.voltage > 100) ? "scorched" : "beautiful";
}
```

### 动机

多态是面向对象编程的关键特性之一。跟其他一切有用的特性一样，它也很容易被滥用。我曾经遇到有人争论说所有条件逻辑都应该用多态取代。我不赞同这种观点。我的大部分条件逻辑只用到了基本的条件语句——if/else和switch/case，并不需要劳师动众地引入多态。但如果发现如前所述的复杂条件逻辑，多态是改善这种情况的有力工具。

## 引入特例

重构前：

```javascript
if (aCustomer === "unknown") customerName = "occupant";
```

重构后：

```javascript
class UnknownCustomer {
get name() {return "occupant";}
```

### 动机

一种常见的重复代码是这种情况：一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。如果我发现代码库中有多处以同样方式应对同一个特殊值，我就会想要把这个处理逻辑收拢到一处。处理这种情况的一个好办法是使用“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理。这样我就可以用一个函数调用取代大部分特例检查逻辑。

特例有几种表现形式。如果我只需要从这个对象读取数据，可以提供一个字面量对象（literal object），其中所有的值都是预先填充好的。如果除简单的数值之外还需要更多的行为，就需要创建一个特殊对象，其中包含所有共用行为所对应的函数。特例对象可以由一个封装类来返回，也可以通过变换插入一个数据结构。

## 引入断言

重构前：

```javascript
if (this.discountRate)
base = base - (this.discountRate * base);
```

重构后：

```javascript
assert(this.discountRate>= 0);
if (this.discountRate)
base = base - (this.discountRate * base);
```

### 动机

断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。断言的失败不应该被系统任何地方捕捉。整个程序的行为在有没有断言出现的时候都应该完全一样。实际上，有些编程语言中的断言可以在编译期用一个开关完全禁用掉。

java中的断言`assert value==1`，正确继续执行，错误中断抛出AssertionError。

# 重构API

## 将查询函数和修改函数分离

## 函数参数化

重构前：

```javascript
function tenPercentRaise(aPerson) {
aPerson.salary = aPerson.salary.multiply(1.1);
} function fivePercentRaise(aPerson) {
aPerson.salary = aPerson.salary.multiply(1.05);
}
```

重构后：

```javascript
function raise(aPerson, factor) {
aPerson.salary = aPerson.salary.multiply(1 + factor);
}
```

### 动机

如果我发现两个函数逻辑非常相似，只有一些字面量值不同，可以将其合并成一个函数，以参数的形式传入不同的值，从而消除重复。这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。

## 移除标记参数

重构前：

```javascript
function setDimension(name, value) {
　if (name === "height") {
　　this._height = value;
　　return;
　}
　if (name === "width") {
　　this._width = value;
　　return;
　}
}
```

重构后：

```javascript
function setHeight(value) {this._height = value;}
function setWidth (value) {this._width = value;}
```

### 动机

“标记参数”是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。

## 保持对象完整

重构前：

```javascript
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (aPlan.withinRange(low, high))
```

重构后：

```javascript
if (aPlan.withinRange(aRoom.daysTempRange))
```

### 动机

如果我看见代码从一个记录结构中导出几个值，然后又把这几个值一起传递给一个函数，我会更愿意把整个记录传给这个函数，在函数体内部导出所需的值。

## 以查询取代参数

重构前：

```javascript
availableVacation(anEmployee, anEmployee.grade);
function availableVacation(anEmployee, grade) {
// calculate vacation...
```

重构后：

```javascript
availableVacation(anEmployee)
function availableVacation(anEmployee) {
const grade = anEmployee.grade;
// calculate vacation...
```

### 动机

函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值，其实原本调用者是不需要费这个力气的。

## 以参数取代查询

重构前：

```javascript
targetTemperature(aPlan)
function targetTemperature(aPlan) {
currentTemperature = thermostat.currentTemperature;
// rest of function...
```

重构后：

```javascript
targetTemperature(aPlan, thermostat.currentTemperature)
function targetTemperature(aPlan, currentTemperature) {
// rest of function...
```

### 动机

需要使用本重构的情况大多源于我想要改变代码的依赖关系——为了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数。这里需要注意权衡：如果把所有依赖关系都变成参数，会导致参数列表冗长重复；如果作用域之间的共享太多，又会导致函数间依赖过度。我一向不善于微妙的权衡，所以“能够可靠地改变决定”就显得尤为重要，这样随着我的理解加深，程序也能从中受益。

如果一个函数用同样的参数调用总是给出同样的结果，我们就说这个函数具有“引用透明性”（referential transparency），这样的函数理解起来更容易。如果一个函数使用了另一个元素，而后者不具引用透明性，那么包含该元素的函数也就失去了引用透明性。只要把“不具引用透明性的元素”变成参数传入，函数就能重获引用透明性。虽然这样就把责任转移给了函数的调用者，但是具有引用透明性的模块能带来很多益处。有一个常见的模式：在负责逻辑处理的模块中只有纯函数，其外再包裹处理I/O和其他可变元素的逻辑代码。借助以参数取代查询，我可以提纯程序的某些组成部分，使其更容易测试、更容易理解。

## 移除设值函数

重构前：

```javascript
class Person {
get name() {...}
set name(aString) {...}
```

重构后：

```javascript
class Person {
get name() {...}
```

### 动机

如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）。

## 以工厂函数取代构造函数

重构前：

```javascript
leadEngineer = new Employee(document.leadEngineer, 'E');
```

重构后：

```javascript
leadEngineer = createEngineer(document.leadEngineer);
```

## 以命令取代函数

重构前：

```javascript
function score(candidate, medicalExam, scoringGuide) {
let result = 0;
let healthLevel = 0;
// long body code
}
```

重构后：

```javascript
class Scorer {
constructor(candidate, medicalExam, scoringGuide) {
this._candidate = candidate;
this._medicalExam = medicalExam;
this._scoringGuide = scoringGuide;
}
execute() {
this._result = 0;
this._healthLevel = 0;
// long body code
}
}
```

### 动机

函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法。这样的对象我称之为“命令对象”（command object），或者简称“命令”（command）。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，就是这种对象存在的意义。与普通的函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，例如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期管理能力。我可以借助继承和钩子对函数行为加以定制。如果我所使用的编程语言支持对象但不支持函数作为一等公民，通过命令对象就可以给函数提供大部分相当于一等公民的能力。同样，即便编程语言本身并不支持嵌套函数，我也可以借助命令对象的方法和字段把复杂的函数拆解开，而且在测试和调试过程中可以直接调用这些方法。

## 以函数取代命令

重构前：

```javascript
class ChargeCalculator {
　constructor (customer, usage){
　　this._customer = customer;
　　this._usage = usage;
　}
　execute() {
　　return this._customer.rate * this._usage;
　}
}
```

重构后：

```javascript
function charge(customer, usage) {
return customer.rate * usage;
}
```

### 动机

命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建。但这种强大是有代价的。大多数时候，我只是想调用一个函数，让它完成自己的工作就好。如果这个函数不是太复杂，那么命令对象可能显得费而不惠，我就应该考虑将其变回普通的函数。

# 处理继承关系

## 函数上移

重构前：

```javascript
class Employee {...}
class Salesman extends Employee {
　get name() {...}
}
class Engineer extends Employee {
　get name() {...}
}
```

重构后：

```javascript
class Employee {
　get name() {...}
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

## 字段上移

重构前：

```javascript
class Employee {...} // Java
class Salesman extends Employee {
　private String name;
}
class Engineer extends Employee {
　private String name;
}
```

重构后：

```javascript
class Employee {
　protected String name;
}
class Salesman extends Employee {...}
class Engineer extends Employee {...}
```

## 构造函数本体上移

重构前：

```javascript
class Party {...}
class Employee extends Party {
　constructor(name, id, monthlyCost) {
　　super();
　　this._id = id;
　　this._name = name;
　　this._monthlyCost = monthlyCost;
　}
}
```

重构后：

```javascript
class Party {
　constructor(name){
　　this._name = name;
　}
}
class Employee extends Party {
　constructor(name, id, monthlyCost) {
　　super(name);
　　this._id = id;
　　this._monthlyCost = monthlyCost;
　}
}
```

## 函数下移

重构前：

```javascript
class Employee {
get quota {...}
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}
```

重构后：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
get quota {...}
}
```

## 字段下移

重构前：

```javascript
class Employee { // Java
　private String quota;
}
class Engineer extends Employee {...}
class Salesman extends Employee {...}
```

重构后：

```javascript
class Employee {...}
class Engineer extends Employee {...}
class Salesman extends Employee {
　protected String quota;
}
```

## 以子类取代类型码

重构前：

```javascript
function createEmployee(name, type) {
return new Employee(name, type);
}
```

重构后：

```javascript
function createEmployee(name, type) {
switch (type) {
case "engineer": return new Engineer(name);
case "salesman": return new Salesman(name);
case "manager": return new Manager (name);
}
```

### 动机

软件系统经常需要表现“相似但又不同的东西”，比如员工可以按职位分类（工程师、经理、销售），订单可以按优先级分类（加急、常规）。表现分类关系的第一种工具是类型码字段——根据具体的编程语言，可能实现为枚举、符号、字符串或者数字。类型码的取值经常来自给系统提供数据的外部服务。

大多数时候，有这样的类型码就够了。但也有些时候，我可以再多往前一步，引入子类。继承有两个诱人之处。首先，你可以用多态来处理条件逻辑。如果有几个函数都在根据类型码的取值采取不同的行为，多态就显得特别有用。引入子类之后，我可以用以多态取代条件表达式（272）来处理这些函数。

## 移除子类

重构前：

```javascript
class Person {
　get genderCode() {return "X";}
} class Male extends Person {
　get genderCode() {return "M";}
} class Female extends Person {
　get genderCode() {return "F";}
}
```

重构后：

```javascript
class Person {
get genderCode() {return this._genderCode;}
}
```

### 动机

子类很有用，它们为数据结构的多样和行为的多态提供支持，它们是针对差异编程的好工具。但随着软件的演化，子类所支持的变化可能会被搬移到别处，甚至完全去除，这时子类就失去了价值。有时添加子类是为了应对未来的功能，结果构想中的功能压根没被构造出来，或者用了另一种方式构造，使该子类不再被需要了。

## 提炼超类

重构前：

```javascript
class Department {
　get totalAnnualCost() {...}
　get name() {...}
　get headCount() {...}
}
class Employee {
　get annualCost() {...}
　get name() {...}
　get id() {...}
}
```

重构后：

```javascript
class Party {
　get name() {...}
　get annualCost() {...}
}
class Department extends Party {
　get annualCost() {...}
　get headCount() {...}
}
class Employee extends Party {
　get annualCost() {...}
　get id() {...}
}
```

## 折叠继承体系

重构前：

```javascript
class Employee {...}
class Salesman extends Employee {...}
```

重构后：

```javascript
class Employee {...}
```

### 动机

在重构类继承体系时，我经常把函数和字段上下移动。随着继承体系的演化，我有时会发现一个类与其超类已经没多大差别，不值得再作为独立的类存在。此时我就会把超类和子类合并起来。

## 以委托取代子类

重构前：

```javascript
class Order {
　get daysToShip() {
　　return this._warehouse.daysToShip;
　}
}
class PriorityOrder extends Order {
　get daysToShip() {
　　return this._priorityPlan.daysToShip;
　}
}
```

重构后：

```javascript
class Order {
　get daysToShip() {
　　return (this._priorityDelegate)
　　　? this._priorityDelegate.daysToShip
　　　: this._warehouse.daysToShip;
　}
}
class PriorityOrderDelegate {
　get daysToShip() {
　　return this._priorityPlan.daysToShip
　}
}
```

### 动机

但继承也有其短板。最明显的是，继承这张牌只能打一次。导致行为不同的原因可能有多种，但继承只能用于处理一个方向上的变化。比如说，我可能希望“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”，也可以是“富人”和“穷人”，但不能同时采用两种继承方式。更大的问题在于，继承给类之间引入了非常紧密的关系。在超类上做任何修改，都很可能破坏子类，所以我必须非常小心，并且充分理解子类如何从超类派生。如果两个类的逻辑分处不同的模块、由不同的团队负责，问题就会更麻烦。

这两个问题用委托都能解决。对于不同的变化原因，我可以委托给不同的类。委托是对象之间常规的关系。与继承关系相比，使用委托关系时接口更清晰、耦合更少。因此，继承关系遇到问题时运用以委托取代子类是常见的情况。

## 以委托取代超类

重构前：

```javascript
class List {...}
class Stack extends List {...}
```

重构后：

```javascript
class Stack {
constructor() {
this._storage = new List();
}
} class List {...}
```

### 动机

在对象技术发展早期，有一个经典的误用继承的例子：让栈（stack）继承列表（list）。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了。

