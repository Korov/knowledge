# 介绍

RocksDB是C++编写的嵌入式kv存储引擎，其键值均允许使用二进制流，支持原子读写操作。RocksDB针对Flash存储进行优化，延迟极小。RocksDB使用LSM存储引擎，纯C++编写。

## 功能

1. 为需要存储TB级别数据到本地FLASH或者RAM的应用服务器设计
2. 针对存储在高速设备的中小键值进行优化——你可以存储在flash或者直接存储在内存
3. 性能碎CPU数量线性提升，对多核系统友好

## 假设与目标

### 性能

RocksDB最初的设计理念就是其应该在高速存储设备以及服务器压力下能有很好的性能表现。他应该能榨取Flash或者RAM子系统提供的所有读写速度潜能。他应该能支持高速的点查询和区间查询。可以通过配置支持很高的随机查询负荷，很高的更新负荷或者两者兼有。其架构应能很简单地对读放大，写放大和存储空间放大进行调优。

## 高度分层架构

RocksDB是一种可以存储任意二进制kv数据的嵌入式存储。RocksDB按顺序组织所有数据，他们的通用操作是Get(key), Put(key), Delete(Key)以及NewIterator()

RocksDB有三种基本的数据结构：mentable，sstfile以及logfile。mentable是一种内存数据结构——所有写入请求都会进入mentable，然后选择性进入logfile。logfile是一种有序写存储结构。当mentable被填满的时候，他会被刷到sstfile文件并存储起来，然后相关的logfile会在之后被安全地删除。sstfile内的数据都是排序好的，以便于根据key快速搜索。

## 特性

### 列族（column families）

RocksDB支持将一个数据库实例按照许多列族进行分片。所有数据库创建的时候都会有一个用"default"命名的列族，如果某个操作不指定列族，他将操作这个default列族。

RocksDB在开启WAL的时候保证即使crash，列族的数据也能保持一致性。通过WriteBatch API，还可以实现跨列族的原子操作。

### 更新操作

调用Put API可以将一个键值对写入数据库。如果该键值已经存在于数据库内，之前的数据会被覆盖。调用Write API可以将多个key原子地写入数据库。数据库保证在一个write调用中，要么所有键值都被插入，要么全部都不被插入。如果其中的一些key在数据库中存在，之前的值会被覆盖。

### get,iterators以及Snapshots

键值对的数据都是按照二进制处理的。键值都没有长度的限制。Get API允许应用从数据库里面提取一个键值对的数据。MultiGet API允许应用一次从数据库获取一批数据。使用MultiGet API获取的所有数据保证相互之间的一致性（版本相同）。

数据库中的所有数据都是逻辑上排好序的。应用可以指定一种键值压缩算法来对键值排序。Iterator API允许对database做RangeScan。Iterator可以指定一个key，然后应用程序就可以从这个key开始做扫描。Iterator API还可以用来对数据库内已有的key生成一个预留的迭代器。一个在指定时间的一致性的数据库视图会在Iterator创建的时候被生成。所以，通过Iterator返回的所有键值都是来自一个一致的数据库视图的。

Snapshot API允许应用创建一个指定时间的数据库视图。Get，Iterator接口可以用于读取一个指定snapshot数据。当然，Snapshot和Iterator都提供一个指定时间的数据库视图，但是他们的内部实现不同。短时间内存在的/前台的扫描最好使用iterator，长期运行/后台的扫描最好使用snapshot。Iterator会对整个指定时间的数据库相关文件保留一个引用计数，这些文件在Iterator释放前，都不会被删除。另一方面，snapshot不会阻止文件删除;作为交换，压缩过程需要知道有snapshot正在使用某个版本的key，并且保证不会在压缩的时候删除这个版本的key。

Snapshot在数据库重启过程不能保持存在：reload RocksDB库会释放所有之前创建好的snapshot

### 事务(transaction)

RocksDB支持多操作事务。其分别支持乐观模式和悲观模式

### 前缀迭代器

多数LSM引擎无法支持高效的RangeScan API，因为他需要对每个文件都进行搜索。不过多数程序也不需要对数据库进行纯随机的区间扫描；多数情况下，应用程序只需要扫描指定前缀的键值即可。RocksDB就利用了这一点。应用可以指定一个键值前缀，配置一个前缀提取器。针对每个键值前缀，RockDB都会其来存储bloom。通过bloom，迭代器在扫描指定前缀的键值的时候，就可以避免扫描那些没有这种前缀键值的文件了。

### 持续性

RocksDB有一个事务日志。所有Puts操作都会被存储在memtable的内存缓冲区中同时可选地插入到事务日志里面。一旦重启，他会重新处理所有记录在事务日志里的日志。

事务日志可以通过配置，存储到跟SST文件不同的目录去。对于那些将所有数据存储在非持续性快速存储介质的情况，这是非常有必要的。同时，你可以通过往较慢但是持续性好的存储介质上写事务日志，来保证数据不会丢失。

每次写操作都有一个标志位，通过WriteOptions来设置，允许指定这个Put操作是不是需要写事务日志。WriteOptions同时允许指定在Put返回成功前，是不是需要调用sync。

### 错误容忍

RocksDB使用校验和检查存储的正确性。每个SST文件块（一般在4K到128K左右）都有一个校验和。一个块一但被写到存储介质，将不再做修改。RocksDB会动态探测硬件是否支持校验和计算，如果允许，将会使用这种支持。

### 多线程压缩

如果应用程序对已经存在的key进行了覆盖，就需要使用压缩将多余的拷贝删除。压缩还会处理删除的键值。如果配置得当，压缩可以通过多线程同时进行。

整个数据库都被按顺序排列在一系列的sstfile里面。当memtable写满，他的内容就会被写入一个在Level-0（L0）的文件。被刷入L0的时候，RocksDB删除在memtable里重复的被覆盖的键值。有些文件会被周期性地读入，然后合并为一些更大的文件——这就叫压缩。

一个LSM数据库的写吞吐量 跟 压缩发生的速度 有直接的关系，特别是当数据被存储在高速存储介质，如SSD和RAM的时候。RocksDB可以配置为通过多线程进行压缩。当使用多线程压缩的时候，跟单线程压缩相比，在SSD介质上的数据库可以看到数十倍的写速度增长。