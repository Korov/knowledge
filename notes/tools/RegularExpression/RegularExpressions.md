正则表达式是一种工具。正则表达式是一些用来匹配和处理文本的字符串。

# 1.匹配单个字符

## 1.1匹配纯文本

直接使用文字去匹配就可以了，Ben可以匹配“Hello name is Ben.”。区别大小写。

有多个匹配结果的时候，大多数正则表达式引擎默认只返回第一个匹配结果。

## 1.2匹配任意字符

特殊字符.（英文句号）可以匹配任何一个单个的字符（匹配除换行符以外的任何单个字符）。在同一个正则表达式里允许使用多个.字符，他们既可以连续出现，也可以间隔着出现在模式的不同位置。

b.n可以匹配ben但是不可以匹配bn和been。

## 1.3转义符

\可以将特殊字符转义成普通字符。

```
b\.n只可以匹配b.n
```

正则表达式经常被简称为模式，他们其实是一些由字符构成的字符串。这些字符串可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符）。

# 2.匹配一组字符

## 2.1匹配多个字符中的某一个

可以使用[]来定义一个字符集合。在字符集合里的所有字符都是该集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。

```
[Ba]en 可以匹配
ben
Ben
aen
Ten
中的Ben和aen
```

## 2.2利用字符区间

条件：第一个字符必须是n或s，第二个字符必须是a，第三个字符可以是任何一个数字

```
区间可以使用元字符-来定义，但是区间的首字符必须大于尾字符，否则正则表达式会失效
[ns]a[0-9]
```

## 2.3取非匹配

除了那个字符集合里的字符，其他字符都可以匹配

```
[^B]en将匹配ben、Ben、aen、Ten中的ben,aen,Ten
```

其他例子:

```
[^0-9a-z]
^的效果将作用与给定字符集合里的所有字符或字符区间
```

# 3.使用元字符

## 3.1空白元字符

| 元字符 | 说明                                  |
| ------ | ------------------------------------- |
| [\b]   | 回退（并删除）一个字符（backspace键） |
| \f     | 换页符                                |
| \n     | 换行符                                |
| \r     | 回车符                                |
| \t     | 制表符（tab键）                       |
| \v     | 垂直制表符                            |

\r\n\r\n可以匹配到空白行

## 3.2匹配特定的字符类别

一些常用的字符集合可以用特殊元字符来代替，这些元字符匹配的是某一类别的字符（术语称之为字符类）。

### 3.2.1匹配数字与非数字

| 元字符 | 说明                          |
| ------ | ----------------------------- |
| \d     | 任何一个数字字符（[0-9]）     |
| \D     | 任何一个非数字字符（\[^0-9]） |

### 3.2.2匹配字母和数字（与非字母和数字）

| 元字符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \w     | 任何一个字母数字字符（大小写均可）或下划线（等价于[a-zA-Z0-9_] |
| \W     | 任何一个非字母数字或或下划线（等价于\[^a-zA-Z0-9_]           |

### 3.2.3匹配空白字符

| 元字符 | 说明                                       |
| ------ | ------------------------------------------ |
| \s     | 任何一个空白字符（等价于[\f\n\r\t\v]）     |
| \S     | 任何一个非空白字符（等价于\[^\f\n\r\t\v]） |

### 3.2.4匹配十六进制或八进制

在正则表达式里，十六进制（逢16进1）数值要用前缀\x来给出。比如说，\x0A对应于ASCII字符10（换行符），其效果等价于\n。

在正则表达式里，八进制（逢8进1）数值要用前缀\0来给出，数值本身可以是两位或三位数字。比如说\011对应于ASCII字符9（制表符），其效果等价于\t。

## 3.3使用POSIX字符类

POSIX字符类是许多（但不是所有）正则表达式实现都支持的一种简写形式。

| 字符类     | 说明                                             |
| ---------- | ------------------------------------------------ |
| [:alnum:]  | 任何一个字母或数字（[a-zA-Z0-9]）                |
| [:alpha:]  | 任何一个字母（[a-zA-Z]）                         |
| [:blank:]  | 空格或制表符（[\t]）                             |
| [:cntrl:]  | ASCII控制字符（ASCII0到31，再加上ASCII 127）     |
| [:digit:]  | 任何一个数字（[0-9]）                            |
| [:graph:]  | 和[:print:]一样，但不包括空格                    |
| [:lower:]  | 任何一个小写字母（[a-z]）                        |
| [:print:]  | 任何一个可打印字符                               |
| [:punct:]  | 既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符 |
| [:space:]  | 任何一个空白字符，包括空格（[\f\n\r\t\v]）       |
| [:upper:]  | 任何一个大写字母                                 |
| [:xdigit:] | 任何一个十六进制数字                             |

我不会用。

# 4.重复匹配

## 4.1匹配一个或多个字符

匹配一个字符（或字符集合）的多次重复，只要简单的给这个字符（或字符集合）加上一个+字符作为后缀就行了。+匹配一个或多个字符（至少一个，不匹配零个字符的情况）。[0-9]+将匹配一个或多个连续的数字。

## 4.2匹配零个或多个字符

使用*元字符，模式B.\* Forta将匹配B Forta, B. Forta, Ben Forta和其他有类似规律的组合。

## 4.3匹配零个或一个字符

使用元字符?，?只能匹配一个字符（或字符集合）的零次或一次出现，最多不超过一次。例如https?:可以匹配http:, https:

## 4.4匹配的重复次数

4{3}，数字4必须再文本中连续出现3次才会匹配。

4{2,5}，数字4必须再文本中连续出现2到5次才会被匹配。

4{2,}，数字4必须再文本中至少连续出现2次才会被匹配。

## 4.5防止匹配过度

\<B>.\*\</B>可以匹配到\<B>aa\</B>ffff\<B>ee\</B>，中间的ffff是我们不需要的。

这是因为*和+都是所谓的“贪婪型”元字符，他们再进行匹配时的行为模式是多多益善而不是适可而止。他们会尽可能的从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配时为止。

可以使用这些元字符的“懒惰型”版本，他的行为与贪婪型正好相反

| 贪婪型元字符 | 懒惰型元字符 |
| ------------ | ------------ |
| *            | *?           |
| +            | +?           |
| {n, }        | {n, }?       |

\<B>.\*?\</B>只可以匹配到\<B>aa\</B>ffff\<B>ee\</B>中的\<B>aa\</B>,\<B>ee\</B>

# 5.位置匹配

## 5.1边界

位置匹配用来解决在什么地方进行字符串匹配操作的问题。

## 5.2单词边界

第一种边界是有限定符\b指定的单词边界。\b用来匹配一个单词的开始或结尾。

\bcat\b只会匹配cat scatt中的cat。

\b匹配的是位于能够用来构成单词的字符（字母、数字和下划线，也就是与\w相匹配的字符）和一个不能用来构成单词的字符（也就是与\W相匹配的字符）之间。

\B表明不匹配一个单词边界，使用\B来查找前后都有多余空格的连字符：\B-\B将会匹配a - b中的-而不会匹配a-b中的-

## 5.3字符串边界

^用来定义字符串的开头，$用来定义字符串的结尾。

^只有在[之后才能发挥求非的作用。如果放在一个字符集合的外面并位于一个模式的开头，^将匹配字符串的开头。

# 6.使用子表达式

## 6.1子表达式

子表达式是一个更大表达式的一部分；把一个表达式划分为一系列子表达式的目的就是为了把哪些子表达式当作一个独立元素来使用。子表达式必须用()括起来。

例如：(cat){2, }将不可以匹配cat而只能匹配catcat这种多个cat相连的数据

## 6.2或操作

|表明是或操作，a|b 可以匹配 a也可以匹配b

## 6.3子表达式允许嵌套

# 7.回溯引用

回溯引用指的是模式的后半部分引用在前半部分中定义的子表达式。

正则表达式[ ]+(\w+)[ ]+\1

匹配结果：of of, are are。匹配到了两个单词。

(\w+)用括号括起来了，说明他是一个子表达式，但是却不是用于重复匹配，是用于回溯引用，\1是一个回溯引用，它引用的正式前面划分出来的子表达式：当(\w+)匹配到单词of的时候，\1也匹配单词of；当(\w+)匹配到单词and的时候，\1也匹配单词and。

# 8.前后查找

## 8.1向前查找

向前查找指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式，从语法上看，一各向前查找模式其实就是一个以?=开头的子表达式，需要匹配的文本跟在=的后面。

例子：`.+(?=:)` 将会匹配 http://和https://中的http和https不包括其后面的:

## 8.2向后查找

一个以`?<=`的子表达式

例子：`(?<=\\$)[0-9.]+` 将会匹配$23.45中的23.45，匹配以$开头后面跟着一个或多个数字或.的字符串，但是匹配结果中不包含$。

## 8.3对前后查找取非

前面的两个叫做正向向前向后查找，还有负向向前向后查找。负向前查找将向前查找不与给定模式相匹配的文本，负向后查找将向后查找不与给定模式相匹配的文本。

| 操作符 | 说明       |
| ------ | ---------- |
| (?=)   | 正向前查找 |
| (?!)   | 负向前查找 |
| (?<=)  | 正向后查找 |
| (?<!)  | 负向后查找 |

例如：\b(?<!\\$)\d+\b 将匹配100 ，$40中的100，(?<!\\$)是一个负向后查找，它使得最终的匹配结果只包含那些不以$开头的数值。

# 9.嵌入条件

## 9.1正则表达式里的条件

正则表达式里的条件要用?来定义

- ?匹配前一个字符或表达式，如果它存在的话
- ?=和?<=匹配前面或后面的文本，如果它存在的话

嵌入条件语言也使用了?，这并没有什么让人感到吃惊的地方，因为嵌入条件不外乎以下两种情况

- 根据一个回溯引用来进行条件处理
- 根据一个前后查找来进行条件处理

### 9.1.1回溯引用条件

回溯引用条件只在一个前面的子表达式搜索取得成功的情况下才允许使用一个表达式。

```
(<[Aa]\s+[^>]+\s*)?<[Ii][Mm][Gg]\s+[^>]+>(?(1)\s*</[Aa]>)
(<[Aa]\s+[^>]+\s*)?将匹配一个<A>或<a>标签（以及标签中的任意属性），这个标签可有可无（因为这个子表达式后面有?）。接下来<[Ii][Mm][Gg]\s+[^>]匹配一个<IMG>机器任意属性，(?(1)\s*</[Aa]>)是一个回溯引用条件，?(1)的含义是：如果第一个回溯引用（具体到本例，就是<A>标签）存在，则使用\s*</[Aa]>继续进行匹配
```

我们刚才使用的模式只在给定条件得到满足时才执行一个表达式。条件还可以有否则表达式，否则表达式只在给定的回溯引用不存在时才会被执行。用来定义这种条件的语法时：

```
(?(backreference)true-regex|false-fegex)
很想Java中的三元运算符
```

### 9.1.2前后查找条件

前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回溯引用条件的语法大同小异，只需把回溯引用（括号里的回溯引用编号）替换为一个完整的前后查找表达式就行了。

```
\d{5}(?(?=-)-\d{4})
\d{5}匹配前5位数字，接下来是一个(?(?=-)-\d{4})形式的向前查找条件。这个条件使用了?=-来匹配一个连字符，如果条件得到满足，-\d{4}将匹配那个连字符和随后的4位数字。
```

# 10.自我总结

## 替换的时候将匹配到的内容放到replace中

```
正则表达式：(sentinel\d.conf)
替换内容：sentinel_config/$1
```

正则表达式必须使用括号包裹，$1表示将用第一个括号中的内容放到替换内容中。

例如：匹配到sentinel3.conf，替换后的内容为sentinel_config/sentinel3.conf

## 替换kindle复制的文本

` +(?=\W)`表示匹配中文前的空格但不包括中文，`(?<=\W) +`匹配中文后的空格但不包括中文

```txt
( +(?=\W))|((?<=\W) +)|\n|(张利兵\..*)
```

## 捕获分组和非捕获分组

```
()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
```

